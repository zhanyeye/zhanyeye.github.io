---
title: Linux基础入门
date: 2019-07-09 14:59:12
tags:
- Linux
---

linux 

![](https://raw.githubusercontent.com/zhanyeye/Figure-bed/deepin-pic/img20190723200950.jpg)

<!--more-->

##### 实验1 Linux 系统简介

安装程序

```shell
sudo apt-get update
sudo apt-get install <name>
```

##### 实验2 基本概念及操作

Linux 用户管理

linux 是一个可以实现多用户登录的操作系统，比如 A 和 B 可以同时登陆通一台主机，他们共享主机资源，也分别有自己的用户空间，存放各自文件。由于Linux 的**用户管理**和**权限机制**，不同用户之间不可以轻易查看、修改彼此文件。

###### 快捷键

| 按键     | 作用                     |
| -------- | ------------------------ |
| ctrl + a | 光标移至输入行头 Home    |
| ctrl + e | 光标移至输入行尾 End     |
| ctrl + k | 删除从光标所在位置到行尾 |

历史输入命令： `pg up   ↑`

###### Shell 常用通配符

| 字符                    | 含义                                           |
| ----------------------- | ---------------------------------------------- |
| *                       | 匹配 0 或多个字符                              |
| ?                       | 匹配任意一个字符                               |
| [list]                  | 匹配 list 中的任意单一字符                     |
| [^list]                 | 匹配 list 中的任意单一字符以外的字符           |
| [c1-c2]                 | 匹配 c1-c2 中的任意单一字符，如：`[0-9]`,[a-z] |
| {string1, string2, ...} | 匹配 string1 或 string2 (...) 其一**字符串**   |
| {c1..c2}                | 匹配 c1-c2 中全部字符 如{1..10}                |

一次创建多个文件：比如： "love_1_linux.txt, love_2_linux.txt, ... love_10_linux.txt"

```shell
$ touch love_{1..10}_shiyanlou.txt
```



###### 获取帮助

**man** 

 是 `Manual pages` 的缩写， 调用手册页, 分为8个区段, 分别从 1~ 8 来标识（查看相应区段，在man 后面加上相应数字即可）

1 ：一般命令,   2 ：系统调用, 3 ：库函数，涵盖C标准函数库

```
$ man <command_name>
```

在 `man` 中使用搜索：`/<你要搜的关键字>`

`n` 切换下一个关键字;  `shift + n`为上一个关键字

`Space` 翻页  `Enter` 向下滚动一行 或 `K,J`  (vim)

`q` 退出

**-- help 参数**

```shell
$ ls --help
```



##### 实验3 用户及文件权限管理

###### 查看用户

```shell
$ who am i
$ who mom likes
```

###### 创建用户

`su <user>`  切换到用户 user

`sudo <cmd> `  以特权级别运行 cmd 命令, 需要当前用户属于 sudo 组

`sudo - <user>`  切换用户，同时改变环境变量  -> 好像和 `sudo -l <user>` 一样

`sudo addusesr <username>`   新建用户

###### 用户组

`groups <user>`  查看用户属于哪个用户组

新建用户如不指定用户组，默认创建一个与用户名相同的用户组

**将用户添加到用户组**

```shell
$ sudo usermod -G <groupname> <username>   
```

**删除用户**

```shell
$ sudo deluser <username> --remove-home
```



###### linux 文件权限

**查看文件权限**

使用较长格式列出文件

```shell
$ ls -l
```

![](https://raw.githubusercontent.com/zhanyeye/Figure-bed/deepin-pic/img20190721085110)

![](https://raw.githubusercontent.com/zhanyeye/Figure-bed/img/img/20190709133321.png)

**变更文件所有者**

将文件的的所有者设为user, 用户组设置为group

```shell
$ chown user[:group] file...
```

**修改文件权限**

![](https://raw.githubusercontent.com/zhanyeye/Figure-bed/img/img/20190709135026.png)

+ 二进制数字表示

  ```shell
  $ chmod --- <file name>    --- 分别代表
  example:
  $ chmod 600 test.text  只有拥有者有读写能力
  ```

+ 加减赋值操作

  ```shell
  $ chmod [g,o,u][+,-][r,w,x] <file name> 
  example:
  $ chmod go-rw iphone6   
  g, o, u  表示 group, others, user
  +, - 表示增加和去掉相应的权限
  ```

  

##### 实验4 Linux 目录结构及文件基本操作

###### FHS 标准

![](https://raw.githubusercontent.com/zhanyeye/Figure-bed/deepin-pic/img20190721085158)

+ 输入命令时：连续2次 `tab` 会显示所有可能的情况

###### 文件操作

新建空白文件：**touch**

+ 主要用来更改已有文件的时间戳（如：最近访问时间，和修改时间）
+ 若只指定一个文件名的，则创建一个空白文件（不会覆盖已有同名文件）

新建目录：**mkdir**

+ 可以创建一个空目录，也可以同时指定创建目录的权限属性
+  `-p`参数： 如果不存在父目录：同时创建一个多级目录

复制文件：**cp** 

`cp [options] source dest `

+ `-r` 参数：递归复制，复制目录时使用

删除文件：**rm**

+ 强制删除 `rm -f <file name>`
+ 删除目录（递归删除）`rm -r <filename>`

移动文件和重命名：**mv**

+ 移动文件：`mv 原目录文件 目的目录`
+ 重命名文件：`mv 旧的文件名 新的文件名`
+ 批量重命名使用： `rename`

###### 查看文件

**cat, tac**

打印文件内容到标准输出，cat 正序显示，tac 倒序

+ `-n` 显示行号 

**nl** 添加行号并打印

**more** 和 **less** 分页查看文件

+ Enter 向下一行
+ Space 下滚动一屏
+ h 帮助，q 退出

**head** 和 **tail** 命令 

+ 默认看前10行或后10行，可以指定行数，－n 1(只看１行)

查看文件类型：**file**



##### 实验5 环境变量与文件查找

shell中创建一个变量

`declare tmp`  其实也可以不用 declare 预声明一个变量，直接即用即创建

`tmp=shiyanlou`

 读取变量的值`echo`

```
$ echo $tmp
```

$ 符号，用于表示引用一个变量的值

###### 环境变量

> 环境变量的作用域比自定义变量的要大，如 Shell 的环境变量作用于自身和它的子进程。在所有的 UNIX 和类 UNIX 系统中，每个进程都有其各自的环境变量设置，且默认情况下，当一个进程被创建时，除了创建过程中明确指定的话，它将继承其父进程的绝大部分环境设置。

通常我们会涉及到的变量类型有三种：

- 当前 Shell 进程私有用户自定义变量，如上面我们创建的 tmp 变量，只在当前 Shell 中有效。
- Shell 本身内建的变量。
- 从自定义变量导出的环境变量。

也有三个与上述三种环境变量相关的命令：`set`，`env`，`export`。这三个命令很相似，都是用于打印环境变量信息，区别在于涉及的变量范围不同。详见下表：

| 命 令    | 说 明                                                        |
| -------- | ------------------------------------------------------------ |
| `set`    | 显示当前 Shell 所有变量，包括其内建环境变量（与 Shell 外观等相关），用户自定义变量及导出的环境变量。 |
| `env`    | 显示与当前用户相关的环境变量; 还可以让命令在指定环境中运行。 |
| `export` | 显示从 Shell 中导出成环境变量的变量; 也能通过它将自定义变量导出为环境变量。 |

 关于哪些变量是环境变量，可以简单地理解成在当前进程的子进程有效则为环境变量，否则不是（有些人也将所有变量统称为环境变量，只是以全局环境变量和局部环境变量进行区分，我们只要理解它们的实质区别即可）。我们这里用 `export` 命令来体会一下，先在 Shell 中设置一个变量 `temp=shiyanlou`，然后再新创建一个子 Shell 查看 `temp` 变量的值：

 ![](https://raw.githubusercontent.com/zhanyeye/Figure-bed/deepin-pic/img20190721085247)

**永久生效**

> 但是问题来了，当你关机后，或者关闭当前的 shell 之后，环境变量就没了啊。怎么才能让环境变量永久生效呢？

按变量的生存周期来划分，Linux 变量可分为两类：

1. 永久的：需要修改配置文件，变量永久生效；
2. 临时的：使用 export 命令行声明即可，变量在关闭 shell 时失效。

这里介绍两个重要文件 `/etc/bashrc`（有的 Linux 没有这个文件） 和 `/etc/profile` ，它们分别存放的是 shell 变量和环境变量。还有要注意区别的是每个用户目录下的一个隐藏文件：

```
.profile 可以用 ls -a 查看
cd /home/shiyanlou
ls -a 
```

这个 .profile 只对当前用户永久生效。而写在 `/etc/profile` 里面的是对所有用户永久生效，所以如果想要添加一个永久生效的环境变量，只需要打开 `/etc/profile`，在最后加上你想添加的环境变量就好啦。

###### 命令的查找路径与顺序

> 我们在 Shell 中输入一个命令，Shell 是怎么知道去哪找到这个命令然后执行的呢？这是通过环境变量 `PATH` 来进行搜索的，熟悉 Windows 的用户可能知道 Windows 中的也是有这么一个 PATH 环境变量。这个 `PATH` 里面就保存了 Shell 中执行的命令的搜索路径。
>
> 当我们在 Shell 中执行一个命令时，系统就会按照 PATH 中设定的路径按照顺序依次到目录中去查找，如果存在同名的命令，则执行先找到的那个。

**创建shell脚本**

```shell
$ cd /home/shiyanlou
$ touch hello_shell.sh
$ gedit hello_shell.sh
```

在脚本中添加如下内容，保存并退出（**注意不要省掉第一行，这不是注释，论坛有用户反映有语法错误，就是因为没有了第一行**）：

```shell
#!/bin/bash

for ((i=0; i<10; i++));do
    echo "hello shell"
done

exit 0
```

为文件添加可执行权限：

```shell
$ chmod 755 hello_shell.sh
```

执行脚本：

```shell
$ cd /home/shiyanlou
$ ./hello_shell.sh
```

如何做到像使用系统命令一样执行自己创建的脚本文件或者程序呢？那就要将命令所在路径添加到 `PATH` 环境变量了。

###### 添加自定义路径到“ PATH ”环境变量

 在前面我们应该注意到 `PATH` 里面的路径是以 `:` 作为分割符的，所以我们可以这样添加自定义路径：

```
$ PATH=$PATH:/home/shiyanlou/mybin
```

**注意这里一定要使用绝对路径。**

现在你就可以在任意目录执行那个命令了（注意需要去掉前面的 `./`）。你可能会意识到这样还并没有很好的解决问题，因为我给 PATH 环境变量追加了一个路径，它也只是在当前 Shell 有效，我一旦退出终端，再打开就会发现又失效了。有没有方法让添加的环境变量全局有效？或者每次启动 Shell 时自动执行上面添加自定义路径到 PATH 的命令？下面我们就来说说后一种方式——让它自动执行。

在每个用户的 home 目录中有一个 Shell 每次启动时会默认执行一个配置脚本，以初始化环境，包括添加一些用户自定义环境变量等等。zsh 的配置文件是 `.zshrc`，相应 Bash 的配置文件为 `.bashrc` 。它们在 `etc` 下还都有一个或多个全局的配置文件，不过我们一般只修改用户目录下的配置文件。

我们可以简单地使用下面命令直接添加内容到 `.zshrc` 中：

```
$ echo "PATH=$PATH:/home/shiyanlou/mybin" >> .zshrc
```

**上述命令中 >> 表示将标准输出以追加的方式重定向到一个文件中，注意前面用到的 > 是以覆盖的方式重定向到一个文件中，使用的时候一定要注意分辨。在指定文件不存在的情况下都会创建新的文件。**

###### 修改和删除已有变量

 

**变量修改**

变量的修改有以下几种方式：

| 变量设置方式                   | 说明                                         |
| ------------------------------ | -------------------------------------------- |
| `${变量名#匹配字串}`           | 从头向后开始匹配，删除符合匹配字串的最短数据 |
| `${变量名##匹配字串}`          | 从头向后开始匹配，删除符合匹配字串的最长数据 |
| `${变量名%匹配字串}`           | 从尾向前开始匹配，删除符合匹配字串的最短数据 |
| `${变量名%%匹配字串}`          | 从尾向前开始匹配，删除符合匹配字串的最长数据 |
| `${变量名/旧的字串/新的字串}`  | 将符合旧字串的第一个字串替换为新的字串       |
| `${变量名//旧的字串/新的字串}` | 将符合旧字串的全部字串替换为新的字串         |

比如要修改我们前面添加到 PATH 的环境变量。为了避免操作失误导致命令找不到，我们先将 PATH 赋值给一个新的自定义变量 path：

```
$ path=$PATH
$ echo $path
$ path=${path%/home/shiyanlou/mybin}
# 或使用通配符,*表示任意多个任意字符
$ path=${path%*/mybin}
```

**变量删除**

可以使用 `unset` 命令删除一个环境变量：

```
$ unset temp
```



######  如何让环境变量立即生效

前面我们在 Shell 中修改了一个配置脚本文件之后（比如 zsh 的配置文件 home 目录下的 `.zshrc`），每次都要退出终端重新打开甚至重启主机之后其才能生效，很是麻烦，我们可以使用 `source` 命令来让其立即生效，如：

```
$ cd /home/shiyanlou
$ source .zshrc
```

`source` 命令还有一个别名就是 `.`，上面的命令如果替换成 `.` 的方式就该是：

```
$ . ./.zshrc
```

在使用`.`的时候，需要注意与表示当前路径的那个点区分开。

注意第一个点后面有一个空格，而且后面的文件必须指定完整的绝对或相对路径名，source 则不需要。

###### 搜索文件

 与搜索相关的命令常用的有 `whereis`，`which`，`find` 和 `locate` 。

- **whereis 简单快速**

  这个搜索很快，因为它并没有从硬盘中依次查找，而是直接从数据库中查询。`whereis` 只能搜索**二进制文件**`-b`，**man 帮助文件**`-m`和**源代码文件**`-s`。

```
$ whereis who
$ whereis find
```

- **locate 快而全**

通过“ /var/lib/mlocate/mlocate.db ”数据库查找，不过这个数据库也不是实时更新的，系统会使用定时任务每天自动执行 `updatedb` 命令更新一次，所以有时候你刚添加的文件，它可能会找不到，需要手动执行一次 `updatedb` 命令（在我们的环境中必须先执行一次该命令）。它可以用来查找指定目录下的不同文件类型，如查找 /etc 下所有以 sh 开头的文件：

```
$ sudo apt-get update
$ sudo apt-get install locate
$ locate /etc/sh
```

> **注意，它不只是在 /bin 目录下查找，还会自动递归子目录进行查找。**

查找 /usr/share/ 下所有 jpg 文件：

```
$ locate /usr/share/\*.jpg
```

> **注意要添加 \* 号前面的反斜杠转义，否则会无法找到。**

如果想只统计数目可以加上 `-c` 参数，`-i` 参数可以忽略大小写进行查找，whereis 的 `-b`、`-m`、`-s` 同样可以使用。

- **which 小而精**

`which` 本身是 Shell 内建的一个命令，我们通常使用 `which` 来确定是否安装了某个指定的软件，因为它只从 `PATH` 环境变量指定的路径中去搜索命令：

```
$ which man
```

- **find 精而细**

`find` 应该是这几个命令中最强大的了，它不但可以通过文件类型、文件名进行查找而且可以根据文件的属性（如文件的时间戳，文件的权限等）进行搜索。`find` 命令强大到，要把它讲明白至少需要单独好几节课程才行，我们这里只介绍一些常用的内容。

这条命令表示去 /etc/ 目录下面 ，搜索名字叫做 interfaces 的文件或者目录。这是 find 命令最常见的格式，千万记住 find 的第一个参数是要搜索的地方：

```
$ sudo find /etc/ -name interfaces
```

> **注意 find 命令的路径是作为第一个参数的， 基本命令格式为 `find [path][option] [action] `。**



##### 实验６　文件打包与解压缩 

**zip：**
打包 ：zip something.zip something （目录请加 -r 参数）

+ -r, 参数表示递归打包包含子目录的全部内容，
+ -q, 参数表示为安静模式，即不向屏幕输出信息，
+ -o, 表示输出文件，需在其后紧跟打包输出文件名
+ -9 ~ -1, 设置压缩级别为 9 和 1（9 最大，1 最小），重新打包
+ -e 参数可以创建加密压缩包
+ -l, 参数将 `LF` 转换为 `CR+LF` 

解包：unzip something.zip

+ 指定路径：-d 参数

**tar：**
打包：tar -cf something.tar something
+ -c, 表示创建一个 tar 包文件，
+ -f, 用于指定创建的文件名，注意文件名必须紧跟在 `-f` 参数之后

解包：tar -xf something.tar
+ -x, 解包一个文件
+ 指定路径：-C 参数
+ -t, 只查看不解包文件
+ 现在我们要使用其它的压缩工具创建或解压相应文件只需要更改一个参数即可：
     *.tar.gz	-z  
     *.tar.xz	-J  
     *.tar.bz2 -j  



##### 实验７　文件系统操作与磁盘管理

###### 查看磁盘和目录的容量

**df**  查看磁盘的容量

+ -h 友好的显示大小

  ![](https://raw.githubusercontent.com/zhanyeye/Figure-bed/deepin-pic/imgDeepinScreenshot_select-area_20190718104510.png)

**du** 查看目录的容量

+ -h 友好的显示大小

+ -d 指定查看目录的深度

  ```
  # 只查看1级目录的信息
  $ du -h -d 0 ~
  # 查看2级
  $ du -h -d 1 ~
  ```

###### 简单的磁盘管理

**dd 命令简介**

`dd`命令用于转换和复制文件，不过它的复制不同于`cp`。之前提到过关于 Linux 的很重要的一点，**一切即文件**，在 Linux 上，硬件的设备驱动（如硬盘）和特殊设备文件（如`/dev/zero`和`/dev/random`）都像普通文件一样，只是在各自的驱动程序中实现了对应的功能，dd 也可以读取文件或写入这些文件。

`dd`的命令行语句与其他的 Linux 程序不同，因为它的命令行选项格式为`选项=值`，而不是更标准的`--选项 值`或`-选项=值`。`dd`默认从标准输入中读取，并写入到标准输出中，但可以用选项`if`（input file，输入文件）和`of`（output file，输出文件）改变。

我们先来试试用dd命令从标准输入读入用户的输入到标准输出或者一个文件中：

```shell
# 输出到文件
$ dd of=test bs=10 count=1 # 或者 dd if=/dev/stdin of=test bs=10 count=1
# 输出到标准输出
$ dd if=/dev/stdin of=/dev/stdout bs=10 count=1
# 注
在打完了这个命令后，继续在终端打字，作为你的输入
```

+ `bs`（block size）用于指定块大小（缺省单位为 Byte，也可为其指定如'K'，'M'，'G'等单位）

+ `count`用于指定块数量

  > 如果，我指定只读取总共 10 个字节的数据，当我输入了“hello shiyanlou”之后加上空格回车总共 16 个字节（一个英文字符占一个字节）内容，显然超过了设定大小。使用`du`和`cat`命令看到的写入完成文件实际内容确实只有 10 个字节（那个黑底百分号表示这里没有换行符）,而其他的多余输入将被截取并保留在标准输入。



**使用 dd 命令创建虚拟镜像文件**

从`/dev/zero`设备创建一个容量为 256M 的空文件：

```shell
$ dd if=/dev/zero of=virtual.img bs=1M count=256
$ du -h virtual.img
```



**使用 mkfs 命令格式化磁盘（我们这里是自己创建的虚拟磁盘镜像）**

我们可以简单的使用下面的命令来将我们的虚拟磁盘镜像格式化为`ext4`文件系统：

```shell
$ sudo mkfs.ext4 virtual.img
```



**使用 mount 命令挂载磁盘到目录树**

> 用户在 Linux/UNIX 的机器上打开一个文件以前，包含该文件的文件系统必须先进行挂载的动作，此时用户要对该文件系统执行 mount 的指令以进行挂载。该指令通常是使用在 USB 或其他可移除存储设备上，而根目录则需要始终保持挂载的状态。又因为 Linux/UNIX 文件系统可以对应一个文件而不一定要是硬件设备，所以可以挂载一个包含文件系统的文件到目录树。
>
> Linux/UNIX 命令行的 mount 指令是告诉操作系统，对应的文件系统已经准备好，可以使用了，而该文件系统会对应到一个特定的点（称为挂载点）。挂载好的文件、目录、设备以及特殊文件即可提供用户使用。

我们先来使用`mount`来查看下主机已经挂载的文件系统：

```shell
sudo mount
```

> 输出的结果中每一行表示一个设备或虚拟设备,每一行最前面是设备名，然后是 on 后面是挂载点，type 后面表示文件系统类型，再后面是挂载选项（比如可以在挂载时设定以只读方式挂载等等）。

那么我们如何挂载真正的磁盘到目录树呢，`mount`命令的一般格式如下：

```shell
mount [options] [source] [directory]
```

一些常用操作：

```
mount [-o [操作选项]] [-t 文件系统类型] [-w|--rw|--ro] [文件系统源] [挂载点]
```

现在直接来挂载我们创建的虚拟磁盘镜像到`/mnt`目录：

```
$ mount -o loop -t ext4 virtual.img /mnt 
# 也可以省略挂载类型，很多时候 mount 会自动识别

# 以只读方式挂载
$ mount -o loop --ro virtual.img /mnt
# 或者mount -o loop,ro virtual.img /mnt
```

**使用 umount 命令卸载已挂载磁盘**



##### 实验8　Linux下的帮助命令

###### 内建命令与外部命令

> **内建命令**实际上是 shell 程序的一部分，其中包含的是一些比较简单的 Linux 系统命令，这些命令是写在bash源码的builtins里面的，由 shell 程序识别并在 shell 程序内部完成运行，通常在 Linux 系统加载运行时 shell 就被加载并驻留在系统内存中。而且解析内部命令 shell 不需要创建子进程，因此其执行速度比外部命令快。比如：history、cd、exit 等等。

> **外部命令**是 Linux 系统中的实用程序部分，因为实用程序的功能通常都比较强大，所以其包含的程序量也会很大，在系统加载时并不随系统一起被加载到内存中，而是在需要时才将其调入内存。虽然其不包含在 shell 中，但是其命令执行过程是由 shell 程序控制的。外部命令是在 Bash 之外额外安装的，通常放在/bin，/usr/bin，/sbin，/usr/sbin等等。比如：ls、vi等。

type 命令来区分命令是内建的还是外部的

```
#得到这样的结果说明是内建命令，正如上文所说内建命令都是在 bash 源码中的 builtins 的.def中
xxx is a shell builtin
#得到这样的结果说明是外部命令，正如上文所说，外部命令在/usr/bin or /usr/sbin等等中
xxx is /usr/bin/xxx
#若是得到alias的结果，说明该指令为命令别名所设定的名称；
xxx is an alias for xx --xxx
```

**help 命令**

help 命令是用于显示 shell 内建命令的简要帮助信息

外部命令基本上都有一个参数--help,这样就可以得到相应的帮助

**man 命令**

例如`man ls`

我们会发现最左上角显示“ LS （1）”，在这里，“ LS ”表示手册名称，而“（1）”表示该手册位于第一章节。这个章节又是什么？在 man 手册中一共有这么几个章节

| 章节数 | 说明                                               |
| ------ | -------------------------------------------------- |
| `1`    | Standard commands （标准命令）                     |
| `2`    | System calls （系统调用）                          |
| `3`    | Library functions （库函数）                       |
| `4`    | Special devices （设备说明）                       |
| `5`    | File formats （文件格式）                          |
| `6`    | Games and toys （游戏和娱乐）                      |
| `7`    | Miscellaneous （杂项）                             |
| `8`    | Administrative Commands （管理员命令）             |
| `9`    | 其他（Linux特定的）， 用来存放内核例行程序的文档。 |

**info 命令**

> 得到的信息比 man 还要多了，info 来自自由软件基金会的 GNU 项目，是 GNU 的超文本帮助系统，能够更完整的显示出 GNU 信息。所以得到的信息当然更多

```
# 安装 info
$ sudo apt-get update
$ sudo apt-get install info
# 查看 ls 命令的 info
$ info ls
```



#####  实验9　Linux任务计划crontab

###### crontab 简介

crontab 命令用于设置周期性被执行的指令。

> crontab 命令从输入设备读取指令，并将其存放于 crontab 文件中，以供之后读取和执行。通常，crontab 储存的指令被守护进程激活，crond 为其守护进程，crond 常常在后台运行，每一分钟会检查一次是否有预定的作业需要执行。
>
> 通过 crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell　script 脚本。时间间隔的单位可以是分钟、小时、日、月、周的任意组合。

crontab 的格式

```
# Example of job definition:
# .---------------- minute (0 - 59)
# |  .------------- hour (0 - 23)
# |  |  .---------- day of month (1 - 31)
# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
# |  |  |  |  |
# *  *  *  *  * user-name command to be executed
```

添加一个计划任务

```shell
crontab -e
```

我们通过这样的一个例子来完成一个任务的添加，在文档的最后一排加上这样一排命令,该任务是每分钟我们会在/home/shiyanlou目录下创建一个以当前的年月日时分秒为名字的空白文件

```shell
*/1 * * * * touch /home/shiyanlou/$(date +\%Y\%m\%d\%H\%M\%S)
```

> 注意 “ % ” 在 crontab 文件中，有结束命令行、换行、重定向的作用，前面加 ” \ ” 符号转义，否则，“ % ” 符号将执行其结束命令行或者换行的作用，并且其后的内容会被做为标准输入发送给前面的命令。

添加成功后我们会得到最后一排 installing new crontab 的一个提示

指令来查看我们添加了哪些任务 `crontab -l`

虽然我们添加了任务，但是如果 cron 的守护进程并没有启动，它根本都不会监测到有任务，当然也就不会帮我们执行，我们可以通过以下2种方式来确定我们的 cron 是否成功的在后台启动，默默的帮我们做事，若是没有就得执行`sudo cron －f &`

```shell
ps aux | grep cron

or

pgrep cron
```

当我们并不需要这个任务的时候我们可以使用这么一个命令去删除任务

```shell
crontab -r
```



###### crontab 的深入

每个用户使用 `crontab -e` 添加计划任务，都会在 `/var/spool/cron/crontabs` 中添加一个该用户自己的任务文档，这样目的是为了隔离。

 如果是系统级别的定时任务，应该如何处理？只需要以 sudo 权限编辑 `/etc/crontab` 文件就可以。

cron 服务监测时间最小单位是分钟，所以 cron 会每分钟去读取一次 /etc/crontab 与 /var/spool/cron/crontabs 里面的內容。 

在 /etc 目录下，cron 相关的目录有下面几个：

![](https://raw.githubusercontent.com/zhanyeye/Figure-bed/deepin-pic/imgDeepinScreenshot_select-area_20190718224433.png)

每个目录的作用：

1. /etc/cron.daily，目录下的脚本会每天执行一次，在每天的6点25分时运行；
2. /etc/cron.hourly，目录下的脚本会每个小时执行一次，在每小时的17分钟时运行；
3. /etc/cron.monthly，目录下的脚本会每月执行一次，在每月1号的6点52分时运行；
4. /etc/cron.weekly，目录下的脚本会每周执行一次，在每周第七天的6点47分时运行；

系统默认执行时间可以根据需求进行修改。



##### 实验10 命令执行顺序控制与管道

简单的顺序执行你可以使用`;`来完成

###### 有选择的执行命令

`&&` 就是用来实现选择性执行的，它表示如果前面的命令执行结果（不是表示终端输出的内容，而是表示命令执行状态的结果）返回0则执行后面的，否则不执行

`|| `表示逻辑或，同样 Shell 也有一个`||`，它们的区别就在于，shell中的这两个符号除了也可用于表示逻辑与和或之外，就是可以实现这里的命令执行顺序的简单控制。`||`在这里就是与`&&`相反的控制效果，当上一条命令执行结果为≠0($?≠0)时则执行它后面的命令

 可以从`$?`环境变量获取上一次命令的返回结果

```shell
which cowsay>/dev/null && echo "exist" || echo "not exist"
```

###### 管道

它表现出来的形式就是将前面每一个进程的输出(stdout)直接作为下一个进程的输入(stdin)。

 ```shell
$ ls -al /etc | less
 ```

###### cut命令,打印每一行的某个字段

打印`/etc/passwd`文件中以`:`为分隔符的第1个字段和第6个字段分别表示用户名和其家目录：

```shell
$ cut /etc/passwd -d ':' -f 1,6
```

+ -d --delimiter=DELIM    :  use DELIM instead of TAB for field delimiter
+ --fields=LIST : select  only  these fields;  also print any line that contains no delimiter character, unless the -s option is specified

打印`/etc/passwd`文件中每一行的前/? N个字符：

```shell
# 前五个（包含第五个）
$ cut /etc/passwd -c -5
# 前五个之后的（包含第五个）
$ cut /etc/passwd -c 5-
# 第五个
$ cut /etc/passwd -c 5
# 2到5之间的（包含第五个）
$ cut /etc/passwd -c 2-5
```

###### grep命令,在文本中或stdin中查找匹配字符串

`grep`命令的一般形式为：

```shell
grep [命令选项]... 用于匹配的表达式 [文件]...
```

我们搜索`/home/shiyanlou`目录下所有包含"shiyanlou"的文本文件，并显示出现在文本中的行号：

```shell
$ grep -rnI "shiyanlou" ~
```

`r` 参数表示递归搜索子目录中的文件,`-n`表示打印匹配项行号，`-I`表示忽略二进制文件

也可以在匹配字段中使用正则表达式，下面简单的演示：

```shell
# 查看环境变量中以"yanlou"结尾的字符串
$ export | grep ".*yanlou$"
# 其中$就表示一行的末尾。
```

###### wc 命令，简单小巧的计数工具

wc 命令用于统计并输出一个文件中行、单词和字节的数目，比如输出`/etc/passwd`文件的统计信息：

```shell
$ wc /etc/passwd
  38   62 2254 /etc/passwd
```

分别只输出行数、单词数、字节数、字符数和输入文本中最长一行的字节数：

```shell
# 行数
$ wc -l /etc/passwd
# 单词数
$ wc -w /etc/passwd
# 字节数
$ wc -c /etc/passwd
# 字符数
$ wc -m /etc/passwd
# 最长行字节数
$ wc -L /etc/passwd
```

###### sort 排序命令

 默认为字典排序：

```shell
$ cat /etc/passwd | sort
```

反转排序：

```shell
$ cat /etc/passwd | sort -r
```

按特定字段排序：

```shell
$ cat /etc/passwd | sort -t':' -k 3
# 上面的-t参数用于指定字段的分隔符，这里是以":"作为分隔符；-k 字段号用于指定对哪一个字段进行排序

# 如果要按照数字排序就要加上-n参数：
$ cat /etc/passwd | sort -t':' -k 3 -n
```

###### uniq 去重命令

 uniq命令只能去连续重复的行，不是全文去重, 可以先排序,在去重

```shell
$ history | cut -c 8- | cut -d ' ' -f 1 | sort | uniq
# 或者
$ history | cut -c 8- | cut -d ' ' -f 1 | sort -u
```

输出重复行

```shell
# 输出重复过的行（重复的只输出一个）及重复次数
$ history | cut -c 8- | cut -d ' ' -f 1 | sort | uniq -dc
# 输出所有重复的行
$ history | cut -c 8- | cut -d ' ' -f 1 | sort | uniq -D
```

+ -c, --count : prefix lines by the number of occurrences
+ -d, --repeated : only print duplicate lines, one for each group

##### 实验11 简单的文本处理

###### tr 命令

可以用来删除一段文本信息中的某些文字。或者将其进行转换。

```
tr [option]...SET1 [SET2]
```

| 选项 | 说明                                                       |
| ---- | ---------------------------------------------------------- |
| `-d` | 删除和set1匹配的字符，注意不是全词匹配也不是按字符顺序匹配 |
| `-s` | 去除set1指定的在输入文本中连续并重复的字符                 |

```shell
# 删除 "hello shiyanlou" 中所有的'o','l','h'
$ echo 'hello shiyanlou' | tr -d 'olh'
e siyanu

# 将"hello" 中的ll,去重为一个l
$ echo 'hello' | tr helo
-s 'l'

# 将输入文本，全部转换为大写或小写输出
$ echo 'input some text here' | tr '[:lower:]' '[:upper:]'
INPUT SOME TEXT HERE
# 上面的'[:lower:]' '[:upper:]'你也可以简单的写作'[a-z]' '[A-Z]',当然反过来将大写变小写也是可以的
```

###### col 命令

可以将`Tab`换成对等数量的空格键，或反转这个操作。

```shell
col [option]
```

| 选项 | 说明                          |
| ---- | ----------------------------- |
| `-x` | 将`Tab`转换为空格             |
| `-h` | 将空格转换为`Tab`（默认选项） |

```shell
# 查看 /etc/protocols 中的不可见字符，可以看到很多 ^I ，这其实就是 Tab 转义成可见字符的符号
$ cat -A /etc/protocols
# 使用 col -x 将 /etc/protocols 中的 Tab 转换为空格,然后再使用 cat 查看，你发现 ^I 不见了
$ cat /etc/protocols | col -x | cat -A
```

######  join命令

 用于将两个文件中包含相同内容的那一行合并在一起

```shell
join [option]... file1 file2
```

| 选项 | 说明                                                 |
| ---- | ---------------------------------------------------- |
| `-t` | 指定分隔符，默认为空格                               |
| `-i` | 忽略大小写的差异                                     |
| `-1` | 指明第一个文件要用哪个字段来对比，默认对比第一个字段 |
| `-2` | 指明第二个文件要用哪个字段来对比，默认对比第一个字段 |

```shell
$ cd /home/shiyanlou
# 创建两个文件
$ echo '1 hello' > file1
$ echo '1 shiyanlou' > file2
$ join file1 file2
1 hello shiyanlou

# 将/etc/passwd与/etc/shadow两个文件合并，指定以':'作为分隔符
$ sudo join -t':' /etc/passwd /etc/shadow
# 将/etc/passwd与/etc/group两个文件合并，指定以':'作为分隔符, 分别比对第4和第3个字段
$ sudo join -t':' -1 4 /etc/passwd -2 3 /etc/group
```

###### paste命令

 `paste`这个命令与`join` 命令类似，它是在不对比数据的情况下，简单地将多个文件合并一起，以`Tab`隔开。

```shell
paste [option] file...
```

| 选项 | 说明                         |
| ---- | ---------------------------- |
| `-d` | 指定合并的分隔符，默认为Tab  |
| `-s` | 不合并到一行，每个文件为一行 |

```shell
$ echo hello > file1
$ echo shiyanlou > file2
$ echo www.shiyanlou.com > file3
hello:shiyanlou:www.shiyanlou.com
$ paste -d ':' file1 file2 file3
$ paste -s file1 file2 file3
hello
shiyanlou
www.shiyanlou.com
```

> 上面这些命令不是所有你都会经常用到，不过它们确是很实用的，熟练掌握之后，可以减轻很多工作量，比如不停的用鼠标操作在 gedit 里面复制粘贴复制粘贴，将两个文件的内容合并为一个文件，这原本只需要一个命令就能完成。



##### 实验12 数据流重定向

| 文件描述符 | 设备文件      | 说明     |
| ---------- | ------------- | -------- |
| `0`        | `/dev/stdin`  | 标准输入 |
| `1`        | `/dev/stdout` | 标准输出 |
| `2`        | `/dev/stderr` | 标准错误 |

> 文件描述符：文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于 UNIX、Linux 这样的操作系统。



######  标准错误重定向

另一个很实用的操作是将标准错误重定向，标准输出和标准错误都被指向伪终端的屏幕显示，所以我们经常看到的一个命令的输出通常是同时包含了标准输出和标准错误的结果的。比如下面的操作：

```
# 使用cat 命令同时读取两个文件，其中一个存在，另一个不存在
$ cat Documents/test.c hello.c
# 你可以看到除了正确输出了前一个文件的内容，还在末尾出现了一条错误信息
# 下面我们将输出重定向到一个文件
$ cat Documents/test.c hello.c > somefile
```

![](https://raw.githubusercontent.com/zhanyeye/Figure-bed/deepin-pic/img20190721085350)

遗憾的是，这里依然出现了那条错误信息，这正是因为如我上面说的那样，标准输出和标准错误虽然都指向终端屏幕，实际它们并不一样。那有的时候我们就是要隐藏某些错误或者警告，那又该怎么做呢。这就需要用到我们前面讲的文件描述符了：

```shell
# 将标准错误重定向到标准输出，再将标准输出重定向到文件，注意要将重定向到文件写到前面
$ cat Documents/test.c hello.c >somefile  2>&1
# 或者只用bash提供的特殊的重定向符号"&"将标准错误和标准输出同时重定向到文件
$ cat Documents/test.c hello.c &>somefilehell
```

**注意你应该在输出重定向文件描述符前加上&,否则shell会当做重定向到一个文件名为1的文件中**

###### 使用tee命令同时重定向到多个文件

你可能还有这样的需求，除了需要将输出重定向到文件,也需要将信息打印在终端。那么你可以使用`tee`命令来实现：

```shell
$ echo 'hello shiyanlou' | tee hello
```

![](https://raw.githubusercontent.com/zhanyeye/Figure-bed/deepin-pic/img20190721085425)



###### 永久重定向

> 你应该可以看出我们前面的重定向操作都只是临时性的，即只对当前命令有效，那如何做到“永久”有效呢，比如在一个脚本中，你需要某一部分的命令的输出全部进行重定向，难道要让你在每个命令上面加上临时重定向的操作嘛

我们可以使用`exec`命令实现“永久”重定向。`exec`命令的作用是使用指定的命令替换当前的 Shell，即使用一个进程替换当前进程，或者指定新的重定向：

```
# 先开启一个子 Shell
$ zsh
# 使用exec替换当前进程的重定向，将标准输出重定向到一个文件
$ exec 1>somefile
# 后面你执行的命令的输出都将被重定向到文件中,直到你退出当前子shell，或取消exec的重定向（后面将告诉你怎么做）
$ ls
$ exit
$ cat somefile
```

![](https://raw.githubusercontent.com/zhanyeye/Figure-bed/deepin-pic/img20190721085602)

###### 创建输出文件描述符

在 Shell 中有9个文件描述符。上面我们使用了也是它默认提供的0,1,2号文件描述符。另外我们还可以使用3-8的文件描述符，只是它们默认没有打开而已。你可以使用下面命令查看当前 Shell 进程中打开的文件描述符：

```shell
$ cd /dev/fd/;ls -Al
```



同样使用`exec`命令可以创建新的文件描述符：

```
$ zsh
$ exec 3>somefile
# 先进入目录，再查看，否则你可能不能得到正确的结果，然后再回到上一次的目录
$ cd /dev/fd/;ls -Al;cd -
# 注意下面的命令>与&之间不应该有空格，如果有空格则会出错
$ echo "this is test" >&3
$ cat somefile
$ exit
```

 ![](https://raw.githubusercontent.com/zhanyeye/Figure-bed/deepin-pic/img20190721085639)

###### 关闭文件描述符

如上面我们打开的3号文件描述符，可以使用如下操作将它关闭：

```shell
$ exec 3>&-
$ cd /dev/fd;ls -Al;cd -
```

###### 完全屏蔽命令的输出

在 Linux 中有一个被称为“黑洞”的设备文件,所有导入它的数据都将被“吞噬”。

> 在类 UNIX 系统中，/dev/null，或称空设备，是一个特殊的设备文件，它通常被用于丢弃不需要的输出流，或作为用于输入流的空文件，这些操作通常由重定向完成。读取它则会立即得到一个EOF。

我们可以利用设个`/dev/null`屏蔽命令的输出：

```shell
$ cat Documents/test.c nefile 1>/dev/null 2>&1
```

上面这样的操作将使你得不到任何输出结果。

###### 使用 xargs 分割参数列表

> xargs 是一条 UNIX 和类 UNIX 操作系统的常用命令。它的作用是将参数列表转换成小块分段传递给其他命令，以避免参数列表过长的问题。
>
> 这个命令在有些时候十分有用，特别是当用来处理产生大量输出结果的命令如 find，locate 和 grep 的结果，详细用法请参看 man 文档。

```shell
$ cut -d: -f1 < /etc/passwd | sort | xargs echo
```

上面这个命令用于将`/etc/passwd`文件按`:`分割取第一个字段排序后，使用`echo`命令生成一个列表。



##### 实验13 正则表达式

###### 基本语法

**选择**

`|`竖直分隔符表示选择，例如"boy|girl"可以匹配"boy"或者"girl"

**数量限定**

数量限定除了我们举例用的`*`,还有`+`加号,`?`问号,如果在一个模式中不加数量限定符则表示出现一次且仅出现一次：

- `+`表示前面的字符必须出现至少一次(1次或多次)，例如，"goo+gle",可以匹配"gooogle","goooogle"等；
- `?`表示前面的字符最多出现一次(0次或1次)，例如，"colou?r",可以匹配"color"或者"colour";
- `*`星号代表前面的字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次），例如，“0*42”可以匹配42、042、0042、00042等。

**范围和优先级** 

`()`圆括号可以用来定义模式字符串的范围和优先级，这可以简单的理解为是否将括号内的模式串作为一个整体。例如，"gr(a|e)y"等价于"gray|grey"，（这里体现了优先级，竖直分隔符用于选择a或者e而不是gra和ey），"(grand)?father"匹配father和grandfather（这里体验了范围，`?`将圆括号内容作为一个整体匹配）。



| 字符      | 描述                                                         |
| --------- | ------------------------------------------------------------ |
| \         | **将下一个字符标记为一个特殊字符、或一个原义字符。**例如，“n”匹配字符“n”。“\n”匹配一个换行符。序列“\\”匹配“\”而“\(”则匹配“(”。 |
| ^         | **匹配输入字符串的开始位置。**                               |
| $         | **匹配输入字符串的结束位置。**                               |
| {n}       | n是一个非负整数。**匹配确定的n次**。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。 |
| {n,}      | n是一个非负整数。**至少匹配n次**。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。 |
| {n,m}     | m和n均为非负整数，其中n<=m。**最少匹配n次且最多匹配m次。**例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。 |
| *         | **匹配前面的子表达式零次或多次**。例如，zo*能匹配“z”、“zo”以及“zoo”。*等价于{0,}。 |
| +         | **匹配前面的子表达式一次或多次**。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。 |
| ?         | **匹配前面的子表达式零次或一次**。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。 |
| ?         | 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。 |
| .         | **匹配除“\n”之外的任何单个字符**。要匹配包括“\n”在内的任何字符，请使用像“(.｜\n)”的模式。 |
| (pattern) | **匹配pattern并获取这一匹配的子字符串**。该子字符串用于向后引用。要匹配圆括号字符，请使用“\(”或“\)”。 |
| x｜y      | **匹配x或y**。例如，“z｜food”能匹配“z”或“food”。“(z｜f)ood”则匹配“zood”或“food”。 |
| [xyz]     | 字符集合（character class）。**匹配所包含的任意一个字符**。例如，“[abc]”可以匹配“plain”中的“a”。其中特殊字符仅有反斜线\保持特殊含义，用于转义字符。其它特殊字符如星号、加号、各种括号等均作为普通字符。脱字符^如果出现在首位则表示负值字符集合；如果出现在字符串中间就仅作为普通字符。**连字符 -如果出现在字符串中间表示字符范围描述；如果出现在首位则仅作为普通字符。** |
| [^xyz]    | 排除型（negate）字符集合。**匹配未列出的任意字符。**例如，`[^abc]`可以匹配“plain”中的“plin”。 |
| [a-z]     | 字符范围。**匹配指定范围内的任意字符。**例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。 |
| [^a-z]    | 排除型的字符范围。**匹配任何不在指定范围内的任意字符**。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。 |

**优先级**

优先级为从上到下从左到右，依次降低：

| 运算符                    | 说明         |
| ------------------------- | ------------ |
| \                         | 转义符       |
| (), (?:), (?=), []        | 括号和中括号 |
| *、+、?、{n}、{n,}、{n,m} | 限定符       |
| ^、$、\任何元字符         | 定位点和序列 |
| ｜                        | 选择         |

更多正则表达式的内容可以参考以下链接：

- [正则表达式wiki](http://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F)
- [几种正则表达式引擎的语法差异](http://www.greenend.org.uk/rjk/tech/regexp.html)
- [各语言各平台对正则表达式的支持](http://en.wikipedia.org/wiki/Comparison_of_regular_expression_engines)

regex的思导图：

![](https://raw.githubusercontent.com/zhanyeye/Figure-bed/deepin-pic/img20190721085729)

###### 基本操作

 `grep`命令用于打印输出文本中匹配的模式串，它使用正则表达式作为模式匹配的条件

| 参数 | 说明                     |
| ---- | ------------------------ |
| `-E` | POSIX扩展正则表达式，ERE |
| `-G` | POSIX基本正则表达式，BRE |
| `-P` | Perl正则表达式，PCRE     |

| 参数           | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| `-b`           | 将二进制文件作为文本来进行匹配                               |
| `-c`           | 统计以模式匹配的数目                                         |
| `-i`           | 忽略大小写                                                   |
| `-n`           | 显示匹配文本所在行的行号                                     |
| `-v`           | 反选，输出不匹配行的内容                                     |
| `-r`           | 递归匹配查找                                                 |
| `-A n`         | n为正整数，表示after的意思，除了列出匹配行之外，还列出后面的n行 |
| `-B n`         | n为正整数，表示before的意思，除了列出匹配行之外，还列出前面的n行 |
| `--color=auto` | 将输出中的匹配项设置为自动颜色显示                           |

**使用基本正则表达式，BRE** 

+ 位置

查找`/etc/group`文件中以"shiyanlou"为开头的行

```shell
$ grep 'shiyanlou' /etc/group
$ grep '^shiyanlou' /etc/group
```

+ 数量

```shell
# 将匹配以'z'开头以'o'结尾的所有字符串
$ echo -e 'zero\nzo\nzoo' | grep 'z.*o'
zero
zo
zoo

# 将匹配以'z'开头以'o'结尾，中间包含一个任意字符的字符串
$ echo -e 'zero\nzo\nzoo' | grep 'z.o'
zoo

# 将匹配以'z'开头,以任意多个'o'结尾的字符串
$ echo -e 'zero\nzo\nzoo' | grep 'zo*$'
zo
zoo

```

+ 选择

```shell
# grep默认是区分大小写的，这里将匹配所有的小写字母
$ echo -e '1234\nabcd' | grep '[a-z]'
# 将匹配所有的数字
$ echo -e '1234\nabcd' | grep '[0-9]'
# 将匹配所有的数字
$ echo -e '1234\nabcd' | grep '[[:digit:]]'
# 将匹配所有的小写字母
$ echo -e '1234\nabcd' | grep '[[:lower:]]'
# 将匹配所有的大写字母
$ echo -e '1234\nabcd' | grep '[[:upper:]]'
# 将匹配所有的字母和数字，包括0-9,a-z,A-Z
$ echo -e '1234\nabcd' | grep '[[:alnum:]]'
# 将匹配所有的字母
$ echo -e '1234\nabcd' | grep '[[:alpha:]]'
```

| 特殊符号     | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| `[:alnum:]`  | 代表英文大小写字母及数字，亦即 0-9, A-Z, a-z                 |
| `[:alpha:]`  | 代表任何英文大小写字母，亦即 A-Z, a-z                        |
| `[:blank:]`  | 代表空白键与 [Tab] 按键两者                                  |
| `[:cntrl:]`  | 代表键盘上面的控制按键，亦即包括 CR, LF, Tab, Del.. 等等     |
| `[:digit:]`  | 代表数字而已，亦即 0-9                                       |
| `[:graph:]`  | 除了空白字节 (空白键与 [Tab] 按键) 外的其他所有按键          |
| `[:lower:]`  | 代表小写字母，亦即 a-z                                       |
| `[:print:]`  | 代表任何可以被列印出来的字符                                 |
| `[:punct:]`  | 代表标点符号 (punctuation symbol)，亦即：" ' ? ! ; : # $...  |
| `[:upper:]`  | 代表大写字母，亦即 A-Z                                       |
| `[:space:]`  | 任何会产生空白的字符，包括空白键, [Tab], CR 等等             |
| `[:xdigit:]` | 代表 16 进位的数字类型，因此包括： 0-9, A-F, a-f 的数字与字节 |

> **注意**：之所以要使用特殊符号，是因为上面的[a-z]不是在所有情况下都管用，这还与主机当前的语系有关，即设置在`LANG`环境变量的值，zh_CN.UTF-8的话[a-z]，即为所有小写字母，其它语系可能是大小写交替的如，"a A b B...z Z"，[a-z]中就可能包含大写字母。所以在使用[a-z]时请确保当前语系的影响，使用[:lower:]则不会有这个问题。



**使用扩展正则表达式，ERE**

要通过`grep`使用扩展正则表达式需要加上`-E`参数，或使用`egrep`。

+ 数量

```shell
# 只匹配"zo"
$ echo 'zero\nzo\nzoo' | grep -E 'zo{1}'
# 匹配以"zo"开头的所有单词
$ echo 'zero\nzo\nzoo' | grep -E 'zo{1,}'
```

+ 选择

```shell
# 匹配"www.shiyanlou.com"和"www.google.com"
$ echo 'www.shiyanlou.com\nwww.baidu.com\nwww.google.com' | grep -E 'www\.(shiyanlou|google)\.com'
# 或者匹配不包含"baidu"的内容
$ echo 'www.shiyanlou.com\nwww.baidu.com\nwww.google.com' | grep -Ev 'www\.baidu\.com'
```

###### sed 流编辑器

用于过滤和转换文本的流编辑器

**sed 命令基本格式：**

```shell
sed [参数]... [执行命令] [输入文件]...
# 形如：
$ sed -i 's/sad/happy/' test # 表示将test文件中的"sad"替换为"happy"
```

| 参数          | 说明                                                         |
| ------------- | ------------------------------------------------------------ |
| `-n`          | 安静模式，只打印受影响的行，默认打印输入数据的全部内容       |
| `-e`          | 用于在脚本中添加多个执行命令一次执行，在命令行中执行多个命令通常不需要加该参数 |
| `-f filename` | 指定执行filename文件中的命令                                 |
| `-r`          | 使用扩展正则表达式，默认为标准正则表达式                     |
| `-i`          | 将直接修改输入文件内容，而不是打印到标准输出设备             |

**sed执行命令格式：**

```shell
[n1][,n2]command
[n1][~step]command
# 其中一些命令可以在后面加上作用范围，形如：
$ sed -i 's/sad/happy/g' test # g表示全局范围
$ sed -i 's/sad/happy/4' test # 4表示指定行中的第四个匹配字符串
```

其中n1,n2表示输入内容的行号，它们之间为`,`逗号则表示从n1到n2行，如果为`～`波浪号则表示从n1开始以step为步进的所有行；command为执行动作，下面为一些常用动作指令：

| 命令 | 说明                               |
| ---- | ---------------------------------- |
| `s`  | 行内替换                           |
| `c`  | 整行替换                           |
| `a`  | 插入到指定行的后面                 |
| `i`  | 插入到指定行的前面                 |
| `p`  | 打印指定行，通常与`-n`参数配合使用 |
| `d`  | 删除指定行                         |

**sed操作举例**

打印指定行

```shell
$ cp /etc/passwd ~
# 打印2-5行
$ nl passwd | sed -n '2,5p'
# 打印奇数行
$ nl passwd | sed -n '1~2p'
```

行内替换 

```shell
# 将输入文本中"shiyanlou" 全局替换为"hehe",并只打印替换的那一行，注意这里不能省略最后的"p"命令
$ sed -n 's/shiyanlou/hehe/gp' passwd
```

行间替换

```shell
$ nl passwd | grep "shiyanlou"
# 删除第21行
$ sed -n '21c\www.shiyanlou.com' passwd
（这里我们只把要删的行打印出来了，并没有真正的删除，如果要删除的话，请使用-i参数）
```

关于sed命令就介绍这么多，你如果希望了解更多sed的高级用法，你可以参看如下链接：

- [sed简明教程](http://coolshell.cn/articles/9104.html)
- [sed单行脚本快速参考](http://sed.sourceforge.net/sed1line_zh-CN.html)
- [sed完全手册](http://www.gnu.org/software/sed/manual/sed.html)

###### awk文本处理语言

 awk所有的操作都是基于pattern(模式)—action(动作)对来完成的，如下面的形式：

```
$ pattern {action}
```

其中pattern通常是表示用于匹配输入的文本的“关系式”或“正则表达式”，action则是表示匹配后将执行的动作。在一个完整awk操作中，这两者可以只有其中一个，如果没有pattern则默认匹配输入的全部文本，如果没有action则默认为打印匹配内容到屏幕。

**awk命令基本格式**

 ```shell
awk [-F fs] [-v var=value] [-f prog-file | 'program text'] [file...]
 ```

其中`-F`参数用于预先指定前面提到的字段分隔符（还有其他指定字段的方式） ，`-v`用于预先为`awk`程序指定变量，`-f`参数用于指定`awk`命令要执行的程序文件，或者在不加`-f`参数的情况下直接将程序语句放在这里，最后为`awk`需要处理的文本输入，且可以同时输入多个文本文件。

**awk操作体验**

先用vim新建一个文本文档

```
$ vim test
```

包含如下内容：

```
I like linux
www.shiyanlou.com
```

使用awk将文本内容打印到终端

```shell
$ awk '{print}' test
```

说明:在这个操作中我是省略了`pattern`，所以`awk`会默认匹配输入文本的全部内容，然后在"{}"花括号中执行动作，即`print`打印所有匹配项，这里是全部文本内容

**将test的第一行的每个字段单独显示为一行**

```shell
$ awk '{
> if(NR==1){
> print $1 "\n" $2 "\n" $3
> } else {
> print}
> }' test

# 或者
$ awk '{
> if(NR==1){
> OFS="\n"
> print $1, $2, $3
> } else {
> print}
> }' test
```

说明:你首先应该注意的是，这里我使用了`awk`语言的分支选择语句`if`,它的使用和很多高级语言如`C/C++`语言基本一致，如果你有这些语言的基础，这里将很好理解。另一个你需要注意的是`NR`与`OFS`，这两个是`awk`内建的变量，

+ `NR`表示当前读入的记录数，你可以简单的理解为当前处理的行数，
+ `OFS`表示输出时的字段分隔符，默认为" "空格，

如上图所见，我们将字段分隔符设置为`\n`换行符，所以第一行原本以空格为字段分隔的内容就分别输出到单独一行了。然后是`$N`:

+ `$N`其中N为相应的字段号，这也是`awk`的内建变量，它表示引用相应的字段，因为我们这里第一行只有三个字段，所以只引用到了`$3`。
+ 除此之外另一个这里没有出现的`$0`，它表示引用当前记录（当前行）的全部内容。

**将test的第二行的以点为分段的字段换成以空格为分隔**

```shell
$ awk -F'.' '{
> if(NR==2){
> print $1 "\t" $2 "\t" $3
> }}' test

# 或者
$ awk '
> BEGIN{
> FS="."
> OFS="\t"  # 如果写为一行，两个动作语句之间应该以";"号分开  
> }{
> if(NR==2){
> print $1, $2, $3
> }}' test
```

说明：这里的`-F`参数，前面已经介绍过，它是用来预先指定待处理记录的字段分隔符。我们需要注意的是除了指定`OFS`我们还可以在`print` 语句中直接打印特殊符号如这里的`\t`，**print打印的非变量内容都需要用""一对引号包围起来**。上面另一个版本，展示了实现预先指定变量分隔符的另一种方式，即使用`BEGIN`，就这个表达式指示了，其后的动作将在所有动作之前执行，这里是`FS`赋值了新的"."点号代替默认的" "空格

awk常用的内置变量

 

| 变量名     | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| `FILENAME` | 当前输入文件名，若有多个文件，则只表示第一个。如果输入是来自标准输入，则为空字符串 |
| `$0`       | 当前记录的内容                                               |
| `$N`       | N表示字段号，最大值为`NF`变量的值                            |
| `FS`       | 字段分隔符，由正则表达式表示，默认为" "空格                  |
| `RS`       | 输入记录分隔符，默认为"\n"，即一行为一个记录                 |
| `NF`       | 当前记录字段数                                               |
| `NR`       | 已经读入的记录数                                             |
| `FNR`      | 当前输入文件的记录数，请注意它与NR的区别                     |
| `OFS`      | 输出字段分隔符，默认为" "空格                                |
| `ORS`      | 输出记录分隔符，默认为"\n"                                   |

关于`awk`的内容本课程将只会包含这些内容，如果你想了解更多，请期待后续课程，或者参看一下链接内容：

- [awk程序设计语言](http://awk.readthedocs.org/en/latest/chapter-one.html)
- [awk简明教程](http://coolshell.cn/articles/9070.html)
- [awk用户指南](http://www.gnu.org/software/gawk/manual/gawk.html)



###### 正则表达式题目

1. 在文件 `/home/shiyanlou/data2` 中匹配数字开头的行，将所有以数字开头的行都写入 `/home/shiyanlou/num` 文件。
2. 在文件 `/home/shiyanlou/data2` 中匹配出正确格式的邮箱，将所有的邮箱写入 `/home/shiyanlou/mail` 文件，注意该文件中每行为一个邮箱。

```shell
grep '^[0-9]' ~/data2 > ~/num

grep -E '^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(.[a-zA-Z0-9_-]+)+$' ~/data2 > ~/mail
```



##### 实验14 linux下软件安装

###### apt-get

`apt-get` 是用于处理 `apt`包的公用程序集，我们可以用它来在线安装、卸载和升级软件包等，下面列出一些`apt-get`包含的常用的一些工具：

| 工具           | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| `install`      | 其后加上软件包名，用于安装一个软件包                         |
| `update`       | 从软件源镜像服务器上下载/更新用于更新本地软件源的软件包列表  |
| `upgrade`      | 升级本地可更新的全部软件包，但存在依赖问题时将不会升级，通常会在更新之前执行一次`update` |
| `dist-upgrade` | 解决依赖关系并升级(存在一定危险性)                           |
| `remove`       | 移除已安装的软件包，包括与被移除软件包有依赖关系的软件包，但不包含软件包的配置文件 |
| `autoremove`   | 移除之前被其他软件包依赖，但现在不再被使用的软件包           |
| `purge`        | 与remove相同，但会完全移除软件包，包含其配置文件             |
| `clean`        | 移除下载到本地的已经安装的软件包，默认保存在/var/cache/apt/archives/ |
| `autoclean`    | 移除已安装的软件的旧版本软件包                               |

下面是一些`apt-get`常用的参数：

| 参数                 | 说明                                                         |
| -------------------- | ------------------------------------------------------------ |
| `-y`                 | 自动回应是否安装软件包的选项，在一些自动化安装脚本中使用这个参数将十分有用 |
| `-s`                 | 模拟安装                                                     |
| `-q`                 | 静默安装方式，指定多个`q`或者`-q=#`,#表示数字，用于设定静默级别，这在你不想要在安装软件包时屏幕输出过多时很有用 |
| `-f`                 | 修复损坏的依赖关系                                           |
| `-d`                 | 只下载不安装                                                 |
| `--reinstall`        | 重新安装已经安装但可能存在问题的软件包                       |
| `--install-suggests` | 同时安装APT给出的建议安装的软件包                            |

关于安装，只需要执行`sudo apt-get install <软件包名>`

很多时候我们需要重新安装一个软件包，`sudo apt-get --reinstall install <name>`

**软件升级**

```shell
# 更新软件源
$ sudo apt-get update
# 升级没有依赖问题的软件包
$ sudo apt-get upgrade
# 升级并解决依赖关系
$ sudo apt-get dist-upgrade
```

**卸载软件**

```shell
sudo apt-get remove <name>

# 不保留配置文件的移除
$ sudo apt-get purge <name>
# 或者 sudo apt-get --purge remove
# 移除不再需要的被依赖的软件包
$ sudo apt-get autoremove
```

**软件搜索**

 当自己刚知道了一个软件，想下载使用，需要确认软件仓库里面有没有，就需要用到搜索功能了，命令如下：

```shell
sudo apt-cache search softname1 softname2 softname3……
```

###### dpkg

> dpkg 是 Debian 软件包管理器的基础，它被伊恩·默多克创建于 1993 年。dpkg 与 RPM 十分相似，同样被用于安装、卸载和供给和 .deb 软件包相关的信息。
>
> "dpkg"是"Debian Package"的简写。

`dpkg`常用参数介绍：

| 参数 | 说明                                            |
| ---- | ----------------------------------------------- |
| `-i` | 安装指定deb包                                   |
| `-R` | 后面加上目录名，用于安装该目录下的所有deb安装包 |
| `-r` | remove，移除某个已安装的软件包                  |
| `-I` | 显示`deb`包文件的信息                           |
| `-s` | 显示已安装软件的信息                            |
| `-S` | 搜索已安装的软件包                              |
| `-L` | 显示已安装软件包的目录信息                      |

```shell
$ sudo dpkg -i <name>
#可能出现了一些错误
$ sudo apt-get 
#-f参数了，修复依赖关系的安装
$ sudo apt-get -f install
```

**查看已安装软件包的安装目录**

 如果你依然在纠结到底linux将软件安装到了什么地方，那么很幸运你将可以通过`dpkg`找到答案

使用`dpkg -L`查看`deb`包目录信息

###### 从二进制包安装

 二进制包的安装比较简单，我们需要做的只是将从网络上下载的二进制包解压后放到合适的目录，然后将包含可执行的主程序文件的目录添加进`PATH`环境变量即可，如果你不知道该放到什么位置，请重新复习第5章关于 Linux 目录结构的内容。



##### 实验15 Linux 进程的概念

###### 进程分类

第一个角度来看，我们可以分为用户进程与系统进程：

- 用户进程：通过执行用户程序、应用程序或称之为内核之外的系统程序而产生的进程，此类进程可以在用户的控制下运行或关闭。
- 系统进程：通过执行系统内核程序而产生的进程，比如可以执行内存资源分配和进程切换等相对底层的工作；而且该进程的运行不受用户的干预，即使是 root 用户也不能干预系统进程的运行。

第二角度来看，我们可以将进程分为交互进程、批处理进程、守护进程

- 交互进程：由一个 shell 终端启动的进程，在执行过程中，需要与用户进行交互操作，可以运行于前台，也可以运行在后台。
- 批处理进程：该进程是一个进程集合，负责按顺序启动其他的进程。
- 守护进程：守护进程是一直运行的一种进程，在 Linux 系统启动时启动，在系统关闭时终止。它们独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。例如 httpd 进程，一直处于运行状态，等待用户的访问。还有经常用的 cron（在 centOS 系列为 crond）进程，这个进程为 crontab 的守护进程，可以周期性的执行用户设定的某些任务。



**进程组与 Sessions**

 每一个进程都会是一个进程组的成员，而且这个进程组是唯一存在的，他们是依靠 PGID（process group ID）来区别的，而每当一个进程被创建的时候，它便会成为其父进程所在组中的一员。

一般情况，进程组的 PGID 等同于进程组的第一个成员的 PID，并且这样的进程称为该进程组的领导者,也就是领导进程，进程一般通过使用 `getpgrp()` 系统调用来寻找其所在组的 PGID，领导进程可以先终结，此时进程组依然存在，并持有相同的PGID，直到进程组中最后一个进程终结。

与进程组类似，每当一个进程被创建的时候，它便会成为其父进程所在 Session 中的一员，每一个进程组都会在一个 Session 中，并且这个 Session 是唯一存在的，

Session 主要是针对一个 tty 建立，Session 中的每个进程都称为一个工作(job)。每个会话可以连接一个终端(control terminal)。当控制终端有输入输出时，都传递给该会话的前台进程组。Session 意义在于将多个 jobs 囊括在一个终端，并取其中的一个 job 作为前台，来直接接收该终端的输入输出以及终端信号。 其他 jobs 在后台运行。

> **前台**（foreground）就是在终端中运行，能与你有交互的

> **后台**（background）就是在终端中运行，但是你并不能与其任何的交互，也不会显示其执行的过程



**工作管理** 

当一个进程在前台运作时我们可以用 `ctrl + c` 来终止它，但是若是在后台的话就不行了。 

我们可以通过 `&` 这个符号，让我们的命令在后台中运行

![](https://raw.githubusercontent.com/zhanyeye/Figure-bed/deepin-pic/imgDeepinScreenshot_select-area_20190719212337.png)

图中所显示的 `[1] 8450`分别是该 job 的 job number 与该进程的 PID，而最后一行的 Done 表示该命令已经在后台执行完毕。

我们还可以通过 `ctrl + z` 使我们的当前工作停止并丢到后台中去

被停止并放置在后台的工作我们可以使用这个命令来查看: `jobs`

![](https://raw.githubusercontent.com/zhanyeye/Figure-bed/deepin-pic/imgDeepinScreenshot_select-area_20190719212738.png)

其中第一列显示的为被放置后台 job 的编号，而第二列的 `＋` 表示最近(刚刚、最后)被放置后台的 job，同时也表示预设的工作，也就是若是有什么针对后台 job 的操作，首先对预设的 job，`-` 表示倒数第二（也就是在预设之前的一个）被放置后台的工作，倒数第三个（再之前的）以后都不会有这样的符号修饰，第三列表示它们的状态，而最后一列表示该进程执行的命令

我们可以通过这样的一个命令将后台的工作拿到前台来

```shell
#后面不加参数提取预设工作，加参数提取指定工作的编号
#ubuntu 在 zsh 中需要 %，在 bash 中不需要 %
fg [%jobnumber]
```

之前我们通过 `ctrl + z` 使得工作停止放置在后台，若是我们想让其在后台运作我们就使用这样一个命令

```shell
#与fg类似，加参则指定，不加参则取预设
bg [%jobnumber]
```

除一个工作，或者重启等等

```shell
#kill的使用格式如下
kill -signal %jobnumber

#signal从1-64个信号值可以选择，可以这样查看
kill －l
```

| 信号值 | 作用                            |
| ------ | ------------------------------- |
| -1     | 重新读取参数运行，类似与restart |
| -2     | 如同 ctrl+c 的操作退出          |
| -9     | 强制终止该任务                  |
| -15    | 正常的方式终止该任务            |

> **注意**

> 若是在使用kill＋信号值然后直接加 pid，你将会对 pid 对应的进程进行操作

> 若是在使用kill+信号值然后 `％jobnumber`，这时所操作的对象是 job，这个数字就是就当前 bash 中后台的运行的 job 的 ID



##### 实验16 Linux 进程管理

###### 进程的查看

+ `top` 实时的查看进程的状态，以及系统的一些信息（如 CPU、内存信息等）
+ `ps` 来静态查看当前的进程信息
+ `pstree` 来查看当前活跃进程的树形结构

######  top 工具的使用

 能实时的查看我们系统的一些关键信息的变化

![](https://raw.githubusercontent.com/zhanyeye/Figure-bed/deepin-pic/imgDeepinScreenshot_select-area_20190719220104.png)

**top 显示的第一排，**

| 内容                         | 解释                                |
| ---------------------------- | ----------------------------------- |
| top                          | 表示当前程序的名称                  |
| 11:05:18                     | 表示当前的系统的时间                |
| up 14:49                     | 表示该机器已经启动了多长时间        |
| 1 user                       | 表示当前系统中只有一个用户          |
| load average: 0.29,0.20,0.25 | 分别对应1、5、15分钟内cpu的平均负载 |

load average 在 wikipedia 中的解释是 the system load is a measure of the amount of work that a computer system is doing 也就是对当前 CPU 工作量的度量，具体来说也就是指运行队列的平均长度，也就是等待 CPU 的平均进程数相关的一个计算值。

我们该如何看待这个load average 数据呢？

假设我们的系统是单 CPU、单内核的，把它比喻成是一条单向的桥，把CPU任务比作汽车。

- load = 0 的时候意味着这个桥上并没有车，cpu 没有任何任务；
- load < 1 的时候意味着桥上的车并不多，一切都还是很流畅的，cpu 的任务并不多，资源还很充足；
- load = 1 的时候就意味着桥已经被车给占满了，没有一点空隙，cpu 的已经在全力工作了，所有的资源都被用完了，当然还好，这还在能力范围之内，只是有点慢而已；
- load > 1 的时候就意味着不仅仅是桥上已经被车占满了，就连桥外都被占满了，cpu 已经在全力工作，系统资源的用完了，但是还是有大量的进程在请求，在等待。若是这个值大于２、大于３，表示进程请求超过 CPU 工作能力的 2 到 ３ 倍。而若是这个值 > 5 说明系统已经在超负荷运作了。



这是单个 CPU 单核的情况，而实际生活中我们需要将得到的这个值除以我们的核数来看。我们可以通过以下的命令来查看 CPU 的个数与核心数

```shell
#查看物理CPU的个数
#cat /proc/cpuinfo |grep "physical id"|sort |uniq|wc -l

#每个cpu的核心数
cat /proc/cpuinfo |grep "physical id"|grep "0"|wc -l
```

通过上面的指数我们可以得知 load 的临界值为 1 ，但是在实际生活中，比较有经验的运维或者系统管理员会将临界值定为0.7。这里的指数都是除以核心数以后的值，不要混淆了

- 若是 load < 0.7 并不会去关注他；
- 若是 0.7< load < 1 的时候我们就需要稍微关注一下了，虽然还可以应付但是这个值已经离临界不远了；
- 若是 load = 1 的时候我们就需要警惕了，因为这个时候已经没有更多的资源的了，已经在全力以赴了；
- 若是 load > 5 的时候系统已经快不行了，这个时候你需要加班解决问题了

通常我们都会先看 15 分钟的值来看这个大体的趋势，然后再看 5 分钟的值对比来看是否有下降的趋势。

 **top 的第二行数据**，基本上第二行是进程的一个情况统计

| 内容            | 解释                |
| --------------- | ------------------- |
| Tasks: 26 total | 进程总数            |
| 1 running       | 1个正在运行的进程数 |
| 25 sleeping     | 25个睡眠的进程数    |
| 0 stopped       | 没有停止的进程数    |
| 0 zombie        | 没有僵尸进程数      |

**来看 top 的第三行数据**，这一行基本上是 CPU 的一个使用情况的统计了

| 内容           | 解释                                                         |
| -------------- | ------------------------------------------------------------ |
| Cpu(s): 1.0%us | 用户空间进程占用CPU百分比                                    |
| 1.0% sy        | 内核空间运行占用CPU百分比                                    |
| 0.0%ni         | 用户进程空间内改变过优先级的进程占用CPU百分比                |
| 97.9%id        | 空闲CPU百分比                                                |
| 0.0%wa         | 等待输入输出的CPU时间百分比                                  |
| 0.1%hi         | 硬中断(Hardware IRQ)占用CPU的百分比                          |
| 0.0%si         | 软中断(Software IRQ)占用CPU的百分比                          |
| 0.0%st         | (Steal time) 是 hypervisor 等虚拟服务中，虚拟 CPU 等待实际 CPU 的时间的百分比 |

CPU 利用率是对一个时间段内 CPU 使用状况的统计，通过这个指标可以看出在某一个时间段内 CPU 被占用的情况，而 Load Average 是 CPU 的 Load，它所包含的信息不是 CPU 的使用率状况，而是在一段时间内 CPU 正在处理以及等待 CPU 处理的进程数情况统计信息，这两个指标并不一样。

**来看 top 的第四行数据**，这一行基本上是内存的一个使用情况的统计了：

| 内容           | 解释                 |
| -------------- | -------------------- |
| 8176740 total  | 物理内存总量         |
| 8032104 used   | 使用的物理内存总量   |
| 144636 free    | 空闲内存总量         |
| 313088 buffers | 用作内核缓存的内存量 |

> **注意**

> 系统中可用的物理内存最大值并不是 free 这个单一的值，而是 free + buffers + swap 中的 cached 的和

来看 top 的第五行数据，这一行基本上是交换区的一个使用情况的统计了

| 内容   | 解释                                                         |
| ------ | ------------------------------------------------------------ |
| total  | 交换区总量                                                   |
| used   | 使用的交换区总量                                             |
| free   | 空闲交换区总量                                               |
| cached | 缓冲的交换区总量,内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖 |

再下面就是进程的一个情况了

| 列名    | 解释                                         |
| ------- | -------------------------------------------- |
| PID     | 进程id                                       |
| USER    | 该进程的所属用户                             |
| PR      | 该进程执行的优先级 priority 值               |
| NI      | 该进程的 nice 值                             |
| VIRT    | 该进程任务所使用的虚拟内存的总数             |
| RES     | 该进程所使用的物理内存数，也称之为驻留内存数 |
| SHR     | 该进程共享内存的大小                         |
| S       | 该进程进程的状态: S=sleep R=running Z=zombie |
| %CPU    | 该进程CPU的利用率                            |
| %MEM    | 该进程内存的利用率                           |
| TIME+   | 该进程活跃的总时间                           |
| COMMAND | 该进程运行的名字                             |

> **注意**

> **NICE 值**叫做静态优先级，是用户空间的一个优先级值，其取值范围是-20至19。这个值越小，表示进程”优先级”越高，而值越大“优先级”越低。nice值中的 -20 到 19，中 -20 优先级最高， 0 是默认的值，而 19 优先级最低

> **PR 值**表示 Priority 值叫动态优先级，是进程在内核中实际的优先级值，进程优先级的取值范围是通过一个宏定义的，这个宏的名称是 MAX_PRIO，它的值为 140。Linux 实际上实现了 140 个优先级范围，取值范围是从 0-139，这个值越小，优先级越高。而这其中的 0 - 99 是实时进程的值，而 100 - 139 是给用户的。

> 其中 PR 中的 100 to 139 值部分有这么一个对应 `PR = 20 + (-20 to +19)`，这里的 -20 to +19 便是nice值，所以说两个虽然都是优先级，而且有千丝万缕的关系，但是他们的值，他们的作用范围并不相同

> ** VIRT **任务所使用的虚拟内存的总数，其中包含所有的代码，数据，共享库和被换出 swap空间的页面等所占据空间的总数

在上文我们曾经说过 top 是一个前台程序，所以是一个可以交互的

| 常用交互命令 | 解释                                                         |
| ------------ | ------------------------------------------------------------ |
| q            | 退出程序                                                     |
| I            | 切换显示平均负载和启动时间的信息                             |
| P            | 根据CPU使用百分比大小进行排序                                |
| M            | 根据驻留内存大小进行排序                                     |
| i            | 忽略闲置和僵死的进程，这是一个开关式命令                     |
| k            | 终止一个进程，系统提示输入 PID 及发送的信号值。一般终止进程用 15 信号，不能正常结束则使用 9 信号。安全模式下该命令被屏蔽。 |



###### ps 工具的使用

```shell
ps aux  #罗列出所有的进程信息
ps axjf
```

| 内容      | 解释                                                         |
| --------- | ------------------------------------------------------------ |
| F         | 进程的标志（process flags），当 flags 值为 1 则表示此子程序只是 fork 但没有执行 exec，为 4 表示此程序使用超级管理员 root 权限 |
| USER      | 进程的拥有用户                                               |
| PID       | 进程的 ID                                                    |
| PPID      | 其父进程的 PID                                               |
| SID       | session 的 ID                                                |
| TPGID     | 前台进程组的 ID                                              |
| %CPU      | 进程占用的 CPU 百分比                                        |
| %MEM      | 占用内存的百分比                                             |
| NI        | 进程的 NICE 值                                               |
| VSZ       | 进程使用虚拟内存大小                                         |
| RSS       | 驻留内存中页的大小                                           |
| TTY       | 终端 ID                                                      |
| S or STAT | 进程状态                                                     |
| WCHAN     | 正在等待的进程资源                                           |
| START     | 启动进程的时间                                               |
| TIME      | 进程消耗CPU的时间                                            |
| COMMAND   | 命令的名称和参数                                             |

> **TPGID**栏写着-1的都是没有控制终端的进程，也就是守护进程

> **STAT**表示进程的状态，而进程的状态有很多，如下表所示

| 状态 | 解释                               |
| ---- | ---------------------------------- |
| R    | Running.运行中                     |
| S    | Interruptible Sleep.等待调用       |
| D    | Uninterruptible Sleep.不可中断睡眠 |
| T    | Stoped.暂停或者跟踪状态            |
| X    | Dead.即将被撤销                    |
| Z    | Zombie.僵尸进程                    |
| W    | Paging.内存交换                    |
| N    | 优先级低的进程                     |
| <    | 优先级高的进程                     |
| s    | 进程的领导者                       |
| L    | 锁定状态                           |
| l    | 多线程状态                         |
| +    | 前台进程                           |

> 其中的 D 是不能被中断睡眠的状态，处在这种状态的进程不接受外来的任何 signal，所以无法使用 kill 命令杀掉处于D状态的进程，无论是 `kill`，`kill -9` 还是 `kill -15`，一般处于这种状态可能是进程 I/O 的时候出问题了。

ps 工具有许多的参数，下面给大家解释部分常用的参数

+ 使用 `-l` 参数可以显示自己这次登陆的 bash 相关的进程信息罗列出来



相对来说我们更加常用下面这个命令，他将会罗列出所有的进程信息 `ps aux`

若是查找其中的某个进程的话，我们还可以配合着 grep 和正则表达式一起使用

```
ps aux | grep <name>
```

此外我们还可以查看时，将连同部分的进程呈树状显示出来 `ps axjf`

当然如果你觉得使用这样的此时没有把你想要的信息放在一起，我们也可以是用这样的命令，来自定义我们所需要的参数显示

```
ps -afxo user,ppid,pid,pgid,command
```

###### pstree 工具的使用

 通过 pstree 可以很直接的看到相同的进程数量，最主要的还是我们可以看到所有进程之间的相关性。

```shell
pstree -up

#参数选择：
#-A  ：各程序树之间以 ASCII 字元來連接；
#-p  ：同时列出每个 process 的 PID；
#-u  ：同时列出每个 process 的所屬账户名称。
```

###### 进程的管理

**kill 命令的掌握**

当一个进程结束的时候或者要异常结束的时候，会向其父进程返回一个或者接收一个 SIGHUP 信号而做出的结束进程或者其他的操作，这个 SIGHUP 信号不仅可以由系统发送，我们可以使用 kill 来发送这个信号来操作进程的结束或者重启等等。

上节课程我们使用 kill 命令来管理我们的一些 job，这节课我们将尝试用 kill 来操作下一些不属于 job 范畴的进程，直接对 pid 下手

```shell
#首先我们使用图形界面打开了 gedit、gvim，用 ps 可以查看到
ps aux

#使用9这个信号强制结束 gedit 进程
kill -9 1608

#我们再查找这个进程的时候就找不到了
ps aux | grep gedit 
```

**进程的执行顺序**

 我们在使用 ps 命令的时候可以看到大部分的进程都是处于休眠的状态，如果这些进程都被唤醒，那么该谁最先享受 CPU 的服务，后面的进程又该是一个什么样的顺序呢？进程调度的队列又该如何去排列呢？

当然就是靠该进程的优先级值来判定进程调度的优先级，而优先级的值就是上文所提到的 PR 与 nice 来控制与体现了

而 nice 的值我们是可以通过 nice 命令来修改的，而需要注意的是 nice 值可以调整的范围是 -20 ~ 19，其中 root 有着至高无上的权力，既可以调整自己的进程也可以调整其他用户的程序，并且是所有的值都可以用，而普通用户只可以调制属于自己的进程，并且其使用的范围只能是 0 ~ 19，因为系统为了避免一般用户抢占系统资源而设置的一个限制

```
#这个实验在环境中无法做，因为权限不够，可以自己在本地尝试

#打开一个程序放在后台，或者用图形界面打开
nice -n -5 vim &

#用 ps 查看其优先级
ps -afxo user,ppid,pid,stat,pri,ni,time,command | grep vim
```

我们还可以用 renice 来修改已经存在的进程的优先级，同样因为权限的原因在实验环境中无法尝试

```
renice -5 pid
```



##### 实验17 Linux 日志系统

在 Linux 中大部分的发行版都内置使用 syslog 系统日志，那么通过前期的课程我们了解到常见的日志一般存放在 `/var/log` 中

根据图中所显示的日志，我们可以根据服务对象粗略的将日志分为两类

- 系统日志
- 应用日志

系统日志主要是存放系统内置程序或系统内核之类的日志信息如 `alternatives.log` 、`btmp` 等等，应用日志主要是我们装的第三方应用所产生的日志如 `tomcat7` 、`apache2` 等等。

接下来我们来看看常见的系统日志有哪些，他们都记录了怎样的信息

| 日志名称           | 记录信息                                                     |
| ------------------ | ------------------------------------------------------------ |
| alternatives.log   | 系统的一些更新替代信息记录                                   |
| apport.log         | 应用程序崩溃信息记录                                         |
| apt/history.log    | 使用 apt-get 安装卸载软件的信息记录                          |
| apt/term.log       | 使用 apt-get 时的具体操作，如 package 的下载、打开等         |
| auth.log           | 登录认证的信息记录                                           |
| boot.log           | 系统启动时的程序服务的日志信息                               |
| btmp               | 错误的信息记录                                               |
| Consolekit/history | 控制台的信息记录                                             |
| dist-upgrade       | dist-upgrade 这种更新方式的信息记录                          |
| dmesg              | 启动时，显示屏幕上内核缓冲信息,与硬件有关的信息              |
| dpkg.log           | dpkg 命令管理包的日志。                                      |
| faillog            | 用户登录失败详细信息记录                                     |
| fontconfig.log     | 与字体配置有关的信息记录                                     |
| kern.log           | 内核产生的信息记录，在自己修改内核时有很大帮助               |
| lastlog            | 用户的最近信息记录                                           |
| wtmp               | 登录信息的记录。wtmp可以找出谁正在进入系统，谁使用命令显示这个文件或信息等 |
| syslog             | 系统信息记录                                                 |