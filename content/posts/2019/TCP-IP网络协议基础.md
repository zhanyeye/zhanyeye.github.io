---
title: TCP/IP网络协议基础
mathjax: true
date: 2019-10-08 20:05:30
tags:
categories:
---

##### TCP/IP 背景和介绍

TCP/IP 不是一个协议，而是一个协议族的统称，里面包括了 `IP` 协议、`ICMP` 协议、`TCP` 协议、以及 `http`、`ftp`、`pop3` 协议等。网络中的计算机都采用这套协议族进行互联。

<!--more-->

提到网络协议栈结构，最著名的当属 OSI 七层模型，但是 TCP/IP 协议族的结构则稍有不同，它们之间的层次结构有如图对应关系：

![](https://raw.githubusercontent.com/zhanyeye/Figure-bed/win-pic/img/20191008201047.png)

可见 TCP/IP 被分为 4 层，每层承担的任务不一样，各层的协议的工作方式也不一样，每层封装上层数据的方式也不一样：

- (1)应用层：应用程序通过这一层访问网络，常见 FTP、HTTP、DNS 和 TELNET 协议；
- (2)传输层：TCP 协议和 UDP 协议；
- (3)网络层：IP 协议，ARP、RARP 协议，ICMP 协议等；
- (4)网络接口层：是 TCP/IP 协议的基层，负责数据帧的发送和接收。

###### IP地址

在 Linux 系统中，可以用 `ifconfig -a` 命令查看自己的 IP 地址：

```
ifconfig -a
```

###### 域名

互联网给每个 IP 地址起了一个别名，习惯上称作域名

域名与计算机的 IP 地址相对应，并把这种对应关系存储在域名服务系统 DNS(Domain Name System) 中，这样用户只需记住域名就可以与指定的计算机进行通信了。

我们可以使用命令 `nslookup` 或者 `ping` 来查看与域名相对应的 IP 地址

###### MAC 地址

MAC（Media Access Control）地址，或称为物理地址、硬件地址，用来定义互联网中设备的位置。

在 TCP/IP 层次模型中，网络层管理 IP 地址，链路层则负责 MAC 地址。因此每个网络位置会有一个专属于它的 IP 地址，而每个主机会有一个专属于它 MAC 地址。

###### 端口号

IP 地址是用来发现和查找网络中的地址，但是不同程序如何互相通信呢？这就需要端口号来识别了。如果把 IP 地址比作一间房子 ，端口就是出入这间房子的门。真正的房子只有几个门，但是端口采用 16 比特的端口号标识，一个 IP 地址的端口可以有 65536（即：2^16）个之多！

服务器的默认程序一般都是通过人们所熟知的端口号来识别的。例如，对于每个 TCP/IP 实现来说，SMTP（简单邮件传输协议）服务器的 TCP 端口号都是 `25`，FTP（文件传输协议）服务器的 TCP 端口号都是 `21`，TFTP（简单文件传输协议）服务器的 UDP 端口号都是 `69`。任何 TCP/IP 实现所提供的服务都用众所周知的 `1－1023` 之间的端口号。这些人们所熟知的端口号由 Internet 端口号分配机构（Internet Assigned Numbers Authority, IANA）来管理。

常用协议对应端口号：

- SSH 22
- FTP 20 和 21
- Telnet 23
- SMTP 25
- TFTP 69
- HTTP 80
- SNMP 161
- Ping 使用ICMP，无具体端口号

###### 封装和分用

**封装**：当应用程序发送数据的时候，数据在协议层次当中自顶向下通过每一层，每一层都会对数据增加一些首部或尾部信息，这样的信息称之为协议数据单元（Protocol Data Unit，缩写为PDU），在分层协议系统里，在指定的协议层上传送的数据单元，包含了该层的协议控制信息和用户信息。如下图所示：

- 物理层（一层）PDU指数据位（Bit）
- 数据链路层（二层）PDU指数据帧（Frame）
- 网络层（三层）PDU指数据包（Packet）
- 传输层（四层）PDU指数据段（Segment）
- 第五层以上为数据（data）

![](https://raw.githubusercontent.com/zhanyeye/Figure-bed/win-pic/img/20191008210945.png)

**分用**：当主机收到一个数据帧时，数据就从协议层底向上升，通过每一层时，检查并去掉对应层次的报文首部或尾部，与封装过程正好相反。



##### 链路层介绍

上一节已经介绍过，网络层协议的数据单元是 **IP 数据报** ，而数据链路层的工作就是把网络层交下来的 IP 数据报 封装为 **帧**（frame）发送到链路上，以及把接收到的帧中的数据取出并上交给网络层。 为达到这一目的，数据链路必须具备一系列相应的功能，主要有：

- 将数据封装为帧（frame），帧是数据链路层的传送单位；
- 控制帧的传输，包括处理传输差错，调节发送速率与接收方相匹配；
- 在两个网络实体之间提供数据链路通路的建立、维持和释放的管理。

数据帧的结构是这样的：

![](https://raw.githubusercontent.com/zhanyeye/Figure-bed/win-pic/img/20191008212516.png)

###### 差错控制

通信系统必须具备发现差错的能力，并采取措施纠正之，使差错控制在所能允许的尽可能小的范围内，这就是差错控制过程，也是数据链路层的主要功能之一。

**反馈重发**

接收方通过对差错编码(奇偶校验码或 CRC 码)的检查，可以判定一帧在传输过程中是否发生了差错。一旦发现差错，一般可以采用**反馈重发**的方法来纠正。这就要求接受方收完一帧后，向发送方反馈一个接收是否正确的信息，使发送方据此做出是否需要重新发送的决定。发送方仅当收到接收方已正确接收的反馈信号后才能认为该帧已经正确发送完毕，否则需要重发直至正确为止。

**计时器**

如果某一帧发送出现问题，一直不能发送成功，为了避免传输过程停滞不前，通常引入 **计时器** (Timer) 来限定接收方发回反馈消息的时间间隔。当发送方发送一帧的同时也启动计时器，若在限定时间间隔内未能收到接收方的反馈信息，即计时器超时(Timeout)，则可认为传出的帧已出错或丢失，就要重新发送。

**序号**

由于同一帧数据可能被重复发送多次，就可能引起接收方多次收到同一帧并将其递交给网络层的情况。为了防止这种情况，可以采用对发送的帧编号的方法，即赋予每帧一个序号，从而使接收方能从该序号来区分是新发送来的帧还是重发的帧，以此来确定要不要将接收到的帧递交给网络层。

###### 流量控制

由于收发双方各自使用的设备工作速率和缓冲存储空间的差异，可能出现发送方的发送能力大于接收方接收能力的现象，此时若不对发送方的发送速率做适当的限制，前面来不及接收的帧将被后面不断发送来的帧“淹没”，从而造成帧的丢失而出错。

由此可见，流量控制实际上是对发送方数据流量的控制，使其发送速率不超过接收方的速率。所以需要一些规则使得发送方知道在什么情况下可以接着发送下一帧，而在什么情况下必须暂停发送，以等待收到某种反馈信息后再继续发送。这就是流量控制。

###### 以太网

以太网(Ether-net)是指 DEC 公司、Intel 公司和 Xerox 公司在 1982 年联合公布的一个标准，这个标准里面使用了一种称作 `CSMA/CD` 的接入方法。而 IEEE802 提供的标准集 802.3(还有一部分定义到了 802.2 中)也提供了一个 CSMA/CD 的标准。

###### PPP（点对点协议）

PPP（点到点协议）是为在同等单元之间传输数据设计的链路层协议。这种链路提供全双工操作，并按照顺序传递数据。设计目的主要是用来通过 **拨号或专线** 方式建立 **点对点** 连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共通的解决方案。

点对点协议（PPP）为在点对点连接上传输多协议数据包提供了一个标准方法。PPP 最初设计是为两个对等节点之间的 IP 流量传输提供一种封装协议。在 TCP/IP 协议集中它是一种用来同步调制连接的数据链路层协议。

###### MTU

为了提供足够快的响应时间，以太网和 IEEE802.3 对数据帧长度都有限制，其最大值分别为 1500 字节和 1492 字节，链路层的这个特性称作 **MTU** ，即 **最大传输单元** 。

当网络层传下来一个 IP 数据报，并且其长度比链路层的 MTU 大，那么网络层就需要对数据报进行分片，使每一片都小于 MTU。

MTU 分为接口 MTU 和路径 MTU：

- 接口 MTU 是指定的接口所允许发送的最大数据长度；
- 路径 MTU 指两台通信主机路径中最小的 MTU 值。路径 MTU 是不对称的，它在两个方向上不一定一致。

用命令 `netstat -in` 可以查看网络接口的 MTU:



##### IP网际协议

###### IP数据报

IP 协议位于网络层，它是 TCP/IP 协议族中最为核心的协议，所有的 TCP、UDP、ICMP 及 IGMP 数据都以 IP 数据报格式传输。IP 协议提供的是 **不可靠** 、 **无连接** 的数据报传送服务。

- `不可靠`（unreliable）：IP 协议不能保证数据报能成功地到达目的地，它仅提供传输服务。当发生某种错误时，IP 协议会丢弃该数据报。传输的可靠性全由上层协议来提供。
- `无连接`（connectionless）：IP 协议对每个数据报的处理是相互独立的。这也说明， IP 数据报可以不按发送顺序接收。如果发送方向接收方发送了两个连续的数据报（先是 A，然后是 B），每个数据报可以选择不同的路线，因此 B 可能在 A 到达之前先到达。

###### IP 地址分类

| 类别 | 最大可指派的网络数 | 第1个可指派的网络号 | 最后一个可指派的网络号 | 每个网络中最大主机数 |
| :--: | ------------------ | ------------------- | ---------------------- | -------------------- |
|  A   | 126 (2^7 – 2)      | 1                   | 126                    | 16777214             |
|  B   | 16383 (2^14 – 1)   | 128.1               | 191.255                | 65534                |
|  C   | 2097151 (2^21 – 1) | 192.0.1             | 223.255.255            | 254                  |

| 网络号 | 主机号                 | 源地址   使用 | 目的地址   使用 | 代表的意思                                |
| ------ | ---------------------- | ------------- | --------------- | ----------------------------------------- |
| 0      | 0                      | 可以          | 不可            | 在本网络上的本主机（见 6.6 节 DHCP 协议） |
| 0      | host-id                | 可以          | 不可            | 在本网络上的某台主机 host-id              |
| 全 1   | 全 1                   | 不可          | 可以            | 只在本网络上进行广播（各路由器均不转发）  |
| net-id | 全 1                   | 不可          | 可以            | 对 net-id 上的所有主机进行广播            |
| 127    | 非全 0 或全 1 的任何数 | 可以          | 可以            | 用作本地软件环回测试之用                  |

###### 子网划分

IP 地址如果只使用 ABCDE 类来划分，会造成大量的浪费：一个有 500 台主机的网络，无法使用 C 类地址。但如果使用一个 B 类地址，6 万多个主机地址只有 500 个被使用，造成 IP 地址的大量浪费。

因此，可以在 ABC 类网络的基础上，进一步划分子网：**占用主机号的前几个位，用于表示子网号** 。

这样 IP 地址就可看作 IP = **网络号** + **子网号** + **主机号**

子网号的位数没有硬性规定，于是我们用 **子网掩码** 来确定一个 IP 地址中哪几位是主机号，具体使用方法如图：

![](https://raw.githubusercontent.com/zhanyeye/Figure-bed/win-pic/img/20191009092142.png)

###### IP 路由选择

如果发送方与接收方直接相连（点对点）或都在一个共享网络上（以太网），那么 IP 数据报就能直接送达。 而大多数情况则是发送方与接收方通过若干个路由器(router)连接，那么数据报就需要经过若干个路由器的转发才能送达，它是怎么选择一个合适的路径来"送货"的呢？

IP 层在内存中有一个路由表（输入命令 `route -n` 可以查看路由表），当收到一份数据报并进行发送时，都要对该表进行搜索：

(1) 从收到的分组的首部提取目的 IP 地址 D。

(2) 先用与路由器直接相连的各网络的子网掩码和 *D* 逐位相“与”，看是否和相应的网 络地址匹配。若匹配，则将分组直接交付。否则就是间接交付，执行 (3)。

(3) 若路由表中有目的地址为 *D* 的特定主机路由，则将分组传送给指明的下一跳路由器；否则，执行 (4)。

(4) 对路由表中的每一行，将子网掩码和 *D* 逐位相“与”。若结果与该行的目的网络地址匹配，则将分组传送给该行指明的下一跳路由器；否则，执行 (5)。

(5) 若路由表中有一个默认路由，则将分组传送给路由表中所指明 的默认路由器；否则，执行 (6)。

(6) 报告转发分组出错。

实验环境中可以使用 `route -n` 查看路由表

###### NAT技术


当你用 ifconfig 查看 IP 地址时，有时你会发现自己的 IP 地址是这样的———192.168.X.X 或 172.16.X.X。这是 C 类网和 B 类网的私有地址，就是俗称的内网 IP。这是因为你的路由器采用了 NAT 技术。

NAT（Network Address Translation，网络地址转换）是 1994 年提出的。当在专用网内部的一些主机本来已经分配到了内网 IP 地址，但现在又想和因特网上的主机通信时，NAT 技术将其内网 IP 地址转换成全球 IP 地址，然后与因特网连接，也就是说，内网的数台主机使用了同一个全球 IP 地址在上网。

NAT 技术实现了宽带共享，而且有助于缓解 IP 地址空间枯竭的问题。

使用 `ifconfig eth0` 查看内网 ip



##### 网络层其他协议

网络层不仅有 IP 协议，还有其它如 ARP、ICMP、IGMP、RARP 等其它协议，这一节我们将对这些协议做介绍。

![](https://raw.githubusercontent.com/zhanyeye/Figure-bed/win-pic/img/20191009094906.png)

###### ARP地址解析协议

1. 功能

   当主机通过数据链路发送数据的时候， **IP 数据报** 会先被封装为一个 **数据帧** ，而 **MAC 地址** 会被添加到数据帧的 **报头** （链路层介绍时已讲过）。 ARP 便是在这个过程中通过目标主机的 IP 地址，查询目标主机的 MAC 地址。

2. 原理

   在你的电脑和路由器中都有一个 **ARP 缓存表** ，其中保存的是近期(20 分钟)与自己有过通信的主机的 IP 地址与 MAC 地址的对应关系。

   ARP 缓存表使用过程：

   - 当主机要发送一个 IP 数据报的时候，会首先查询一下自己的 ARP 缓存表；
   - 如果在 ARP 缓存表中找到对应的 MAC 地址，则将 IP 数据报封装为数据帧，把 MAC 地址放在帧首部，发送数据帧；
   - 如果查询的 IP－MAC 值对不存在，那么主机就向网络中广播发送一个 ARP 请求数据帧，ARP 请求中包含待查询 IP 地址；
   - 网络内所有收到 ARP 请求的主机查询自己的 IP 地址，如果发现自己符合条件，就回复一个 ARP 应答数据帧，其中包含自己的 MAC 地址；
   - 收到 ARP 应答后，主机将其 IP - MAC 对应信息存入自己的 ARP 缓存，然后再据此封装 IP 数据报，再发送数据帧。

   你可以通过命令 `arp -a` 查看 ARP 缓存表(表项记录 20 分钟超时)，这里介绍几个主要选项：

   | 命令 | 描述                                              |
   | ---- | ------------------------------------------------- |
   | `-a` | 显示 ARP 高速缓存中的所有内容                     |
   | `-d` | 从 ARP 缓冲区中删除指定主机的 ARP 条目            |
   | `-s` | 设置指定的主机的 IP 地址与 MAC 地址的静态映射     |
   | `-v` | 显示详细的arp缓冲区条目，包括缓冲区条目的统计信息 |

3. ARP 代理

   如果 ARP 请求是从一个网络上的主机发往另一个网络上的主机，那么连接这两个网络的路由器就可以回答该 ARP 请求，这个过程称作 **代理 ARP**（Proxy ARP）。

   **当连接这两个网络的路由器收到该 ARP 请求时，它会发现自己有通向目的主机的路径，随后它会将自己(路由器)的 MAC 地址回复给源主机。源主机会认为路由器的 MAC 地址就是目的主机的 MAC 地址，而对于随后发来的数据帧，路由器会转发到它后面真实 MAC 地址的目的主机**。

   两个物理网络之间的路由器可以使这两个网络彼此透明化，在这种情况下，只要路由器设置成一个 ARP 代理，以响应一个网络到另一个网络主机的 ARP 请求，两个物理网络就可以使用相同的网络号。

4. ARP 欺骗

   从 ARP 代理的原理可以看出来：IP - MAC 的对应信息很容易被伪造！黑客可以伪造 ARP 应答数据帧而欺骗 ARP 请求者，从而达到截获数据的目的

###### RARP逆向地址解析协议

听名字就知道，RARP 与 ARP 是相反的关系，用于将 MAC 地址转换为 IP 地址。对应于 ARP，RARP 请求以广播方式传送，而 RARP 应答一般是单播传送的。

某些设备，比如无盘机在启动时可能不知道自己的 IP 地址，它们可以将自己的 MAC 地址使用 RARP 请求广播出去，RARP 服务器就会响应并回复无盘机的 IP 地址。

> RARP 在目前的应用中已极少被使用，不再赘述了。

###### ICMP控制报文协议

通信过程中发生各种问题时，ICMP 将问题反馈，通过这些信息，管理者可以对所发生的问题作出诊断，然后采取适当的措施去解决它。

![](https://raw.githubusercontent.com/zhanyeye/Figure-bed/win-pic/img/20191009101818.png)

ICMP应用

+ PING (Packet InterNet Groper) 

  > PING 用来测试两个主机之间的连通性。
  > PING 使用了 ICMP 回送请求与回送回答报文。
  > PING 是应用层直接使用网 络层 ICMP 的例子，它没有通过运输层的 TCP 或UDP。 

+ Traceroute

ICMP 差错报告报文共有4 种:

+ 终点不可达 
+ 时间超过  
+ 参数问题 
+ 改变路由（重定向）(Redirect)  

也有一些出现差错而不产生 ICMP 报文的情况，比如：

- ICMP 差错报文

- 目的地址是广播或多播地址

- 作为链路层广播的数据报

- 不是 IP 分片的第一片

- 源地址不是单个主机的数据报（源不能为零地址、环回地址、广播多播地址）

  

###### ping程序

1. 简介

   ping 程序是对两台主机之间连通性进行测试的基本工具，它只是利用 ICMP 回显请求和回显应答报文，而不用经过传输层（TCP/UDP）。

   ping 程序通过在 ICMP 报文数据中存放发送请求的时间值来计算往返时间，当应答返回时，用当前时间减去存放在 ICMP 报文中的时间值，即是往返时间。

   ping 程序使用方法为 `ping IP 地址` ，ping 命令还可以加上参数，实现更多的功能：

   - -n 只输出数值
   - -q 不显示任何传送封包的信息，只显示最后的结果
   - -r 忽略普通的 Routing Table，直接将数据包送到远端主机上，通常是查看本机的网络接口是否有问题
   - -R 记录路由过程
   - -v 详细显示指令的执行过程
   - -c 数目：在发送指定数目的包后停止
   - -i 秒数：设定间隔几秒传送一个网络封包给一台机器，预设值是一秒送一次
   - -t 存活数值：设置存活数值 TTL 的大小

2. TTL值

   **TTL** 是 Time To Live 的缩写，该字段指定 IP 包被路由器丢弃之前允许通过的最大网段数量。可以去回顾一下上节的 IP 报文结构图。

   TTL 是 IPv4 包头的一个 8 bit 字段，它的作用是限制 IP 数据包在计算机网络中的存在时间，即 IP 数据包在计算机网络中可以转发的最大条数。

   假如没有 TTL 字段，网络中的 IP 包将越来越多造成网络阻塞，TTL 避免 IP 包在网络中的无限循环和收发，节省了网络资源，并能使 IP 包的发送者能收到告警消息。

3. Ping 命令判断操作系统

   ping 命令会返回一个 TTL 值，我们可以使用它来判断目标的操作系统类型。 常见操作系统缺省 TTL 值如下:

   - UNIX TTL: 255
   - Linux TTL: 64
   - WINDOWS 95/98 TTL: 32
   - Windows NT 4.0/2000/XP/2003/7/8/10 TTL：128

   在环境里面 `ping 127.0.0.1` 查看自己的TTL值：

   ![](https://raw.githubusercontent.com/zhanyeye/Figure-bed/win-pic/img/20191009105709.png)

   TTL 为 64 ，实验楼环境为 linux，结果相符。 此方法主要用于粗略的判断，想更加准确的获取服务器操作系统信息请学习实验楼的 `NMAP` 相关课程。

##### traceroute 程序