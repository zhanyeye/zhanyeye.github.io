<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[leetcode 题解]]></title>
    <url>%2F2019%2F04%2F30%2F19-04-30-leetcode-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Two SumEasy Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: 1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 注意每个元素只能使用一次 两个坑： 当一个数和它的匹配相同是如 [3, 4] target: 6; 6 - 3 = 3,但是这个3 不能再用了 [3, 3] target: 6; 第一个3不能用，但是第二个3 还可以用 先将数和索引作为键值对加入map，再去从map中找target - nums[i] 1234567891011121314151617181920//2019-04-30class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map&lt;int, int&gt; mp; vector&lt;int&gt; ans; for (int i = 0; i &lt; nums.size(); i++) &#123; mp[nums[i]] = i; &#125; for (int i = 0; i &lt; nums.size(); i++) &#123; int need = target - nums[i]; if (mp.count(need) &amp;&amp; mp[need] != i) &#123; //注意顺序不能反过来！因为mp[need]若不存在，会被初始化为0 ans.push_back(i); ans.push_back(mp[need]); break; &#125; &#125; return ans; &#125;&#125;; The basic idea is to maintain a hash table for each element num in nums, using num as key and its index (0-based) as value. For each num, search for target - num in the hash table. If it is found and is not the same element as num, then we are done. The code is as follows. Note that each time before we add num to mp, we search for target - num first and so we will not hit the same element. 1234567891011121314class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map&lt;int, int&gt; mp; for (int i = 0; i &lt; nums.size(); i++) &#123; int matching = target - nums[i]; if (mp.find(matching) != mp.end()) &#123; return &#123;mp[matching], i&#125;; &#125; mp[nums[i]] = i; &#125; return &#123;&#125;; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019-04-29 阅读]]></title>
    <url>%2F2019%2F04%2F29%2F2019-04-29-%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[19-04-28 Dijkstra 最短路径算法]]></title>
    <url>%2F2019%2F04%2F28%2F19-04-28-Dijkstra-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[单源最短路问题在带权图 G=(V,E) 中，每条边都有一个权值 wi，即边的长度。路径的长度为路径上所有边权之和。单源最短路问题是指：求源点 s 到图中其余各顶点的最短路径。 如果用我们之前学习的 dfs 来解决单源最短路问题，效率上会很慢，能解决的问题的数据规模非常小。 而 bfs 能解决的最短路问题只限制在边权为 1 的图上。对于边权不同的图，利用 bfs 求解最短路是错误的。 解决单源最短路径问题常用 Dijkstra 算法，用于计算一个顶点到其他所有顶点的最短路径。Dijkstra 算法的主要特点是以起点为中心，逐层向外扩展（这一点类似于 bfs，但是不同的是，bfs 每次扩展一个层，但是 Dijkstra 每次只会扩展一个点），每次都会取一个最近点继续扩展，直到取完所有点为止 非负权图 , 贪心思想 算法流程我们定义带权图 G 所有顶点的集合为 V，接着我们再定义已确定从源点出发的最短路径的顶点集合为 U，初始集合 U 为空，记从源点 s 出发到每个顶点 v 的距离为 dist_v，初始 dist_s=0，其他dist_v为∞。接着执行以下操作： 从 V−U 中找出一个距离源点最近的顶点 v，将 v 加入集合 U。 并用 dist_v 和点 v 连出的边来更新和 v 相邻的、不在集合 U 中的顶点的 dist，这一步称为松弛操作。 重复步骤 1 和 2，直到 V=U或找不出一个从 s 出发有路径到达的顶点，算法结束。 如果最后V !=U，说明有顶点无法从源点到达；否则每个 dist_i表示从 s 出发到顶点 i 的最短距离。 Dijkstra 算法的时间复杂度为O(V^2)，其中 V 表示顶点的数量。 算法演示 接下来，我们用一个例子来说明这个算法。 初始每个顶点的 dist 设置为无穷大 inf，源点 M 的 dist_M 设置为 0。 当前U=∅，V−U 中 dist 最小的顶点是 M。 从顶点 M 出发，更新相邻点的 dist。 更新完毕，此时 U={M}， V−U 中 dist 最小的顶点是 W。 从 W 出发，更新相邻点的 dist。 更新完毕，此时 U={M,W}， V−U 中 dist 最小的顶点是 E。 从 E 出发，更新相邻顶点的 dist。 更新完毕，此时 U={M,W,E}， V−U 中 dist最小的顶点是 X*。 从 X 出发，更新相邻顶点的 dist。 更新完毕，此时 U={M,W,E,X}， V−U 中 dist 最小的顶点是 D*。 从 D 出发，没有其他不在集合 U 中的顶点。 此时U=V，算法结束，单源最短路计算完毕。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 1001;const int M = 10001;const int INF = 0x3f3f3f3f;struct edge &#123; int v, w, next; edge() &#123;&#125; edge(int _v, int _w, int _next): v(_v), w(_w), next(_next) &#123;&#125;&#125; e[M * 2];int head[N];int cnt = 0; //链表大小void insert(int u, int v, int w) &#123; e[cnt] = edge(v, w, head[u]); head[u] = cnt++;&#125;void insert2(int u, int v, int w) &#123; insert(u, v, w); insert(v, u, w);&#125;void init() &#123; memset(head, -1, sizeof head); cnt = 0;&#125;int n, m;int dis[N];bool vis[N];void dijkstra(int u) &#123; memset(vis, false, sizeof vis); memset(dis, 0x3f, sizeof dis); dis[u] = 0; for (int i = 0; i &lt; n; i++) &#123; int min_dis = INF, min_index = -1; for (int j = 1; j &lt;= n; j++) &#123; //j 从0 还是从 1 根据情况而定 if (!vis[j] &amp;&amp; dis[j] &lt; min_dis) &#123; min_index = j; min_dis = dis[j]; &#125; &#125; if (min_dis == -1) &#123; //图不是连通图 return; &#125; vis[min_index] = true; for (int j = head[min_index]; ~j; j = e[j].next) &#123; int v = e[j].v; int w = e[j].w; if (!vis[v] &amp;&amp; dis[v] &gt; dis[min_index] + w) &#123; dis[v] = dis[min_index] + w; &#125; &#125; &#125;&#125;int main() &#123; init(); int u, v, w; cin &gt;&gt; n &gt;&gt; m; while (m--) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; insert2(u, v, w); &#125; dijkstra(1); cout &lt;&lt; dis[n] &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图的基础]]></title>
    <url>%2F2019%2F04%2F26%2F19-04-26%20%E5%9B%BE%E7%9A%84%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[邻接矩阵基于 vector 邻接表带权邻接表 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;struct node &#123; int v, w;&#125;;vector&lt;node&gt; G[11];void insert1(int u, int v, int w) &#123; node temp; temp.v = v; temp.w = w; G[u].push_back(temp);&#125;void insert2(int u, int v, int w) &#123; insert1(u, v, w); insert1(v, u, w);&#125;void input() &#123; int m; cin &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; insert2(u, v, w); &#125;&#125;void output() &#123; for (int i = 1; i &lt;= 10; i++) &#123; for (int j = 0; j &lt; G[i].size(); j++) &#123; cout &lt;&lt; "(" &lt;&lt; i &lt;&lt; ", " &lt;&lt; G[i][j].v &lt;&lt; ", " &lt;&lt; G[i][j].w &lt;&lt; ")" &lt;&lt; endl; &#125; &#125;&#125;int main() &#123; input(); output(); return 0;&#125; 基于 链表 的邻接表由于vector的常数较大，对于某些时间限制较为严格的情景，使用vector存储邻接表会导致程序有超时的风险 12345678910111213141516171819202122232425262728293031323334353637383940const int N = 1000000;const int M = 10000;struct edge &#123; int v, w; int next; //其实这里的next指向前驱 edge() &#123;&#125; edge(int _v, int _w, int _next): v(_v), w(_w), next(_next) &#123;&#125; &#125; e[M];int head[N]; //head[i] 表示从点 i int cnt; //记录边的数量，来作为边的索引void init() &#123; memset(head, -1, sizeof head); //开始链表为空，头指针都初始化为 -1 cnt = 0;&#125;// 插入单向边void insert(int u, int v, int w) &#123; e[cnt] = edge(v, w, head[u]); //新建一个终点为 v, 权值为 w 的边，插入到表示 u 的链表尾部 head[u] = cnt; //将点 u 的 head指针移向后移一位，即刚刚插入的那个节点 cnt++; &#125;// 插入双向边void insert2(int u, int v, int w) &#123; insert(u, v, w); insert(v, u, w);&#125;// 输出整张图中的所有边: !注意：输出的顺序和插入的顺序是相反的void output(int n) &#123; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; i &lt;&lt; " : "; for (int j = head[i]; ~j; j = e[j].next) &#123; // 遍历从 i 连出的所有边 cout &lt;&lt; "-&gt; &lt;[" &lt;&lt; e[j].v &lt;&lt; "]," &lt;&lt; e[j].w &lt;&lt; "&gt;"; &#125; cout &lt;&lt; endl; &#125;&#125; 练习关系查询 输入 n 对朋友关系，朋友关系是相互的。a 是 b 的朋友，b 也是 a 的朋友。（无向图）然后有 m 次查询，每次查询询问 a 和 b 是否是朋友。输入格式第一行输入一个整数 n(1≤n≤100)。接下来 n 行，每行输入两个名字，表示一对朋友关系。接下来一行输入一个整数 m(1≤m≤100)，表示 m 个查询。接下来 m 行，每行输入两个名字，表示一次查询。输入中的名字只包含大小写字母，长度不超过 20。输出格式对于每次查询，如果他们是朋友，输出一行&quot;Yes&quot;，否则输出一行&quot;No&quot;。样例输入 1234567891011&gt; 5&gt; Mary Tom&gt; Islands Barty&gt; Andy Amy&gt; Islands Amy&gt; Tom Mary&gt; 3&gt; Amy Andy&gt; Islands Tom&gt; Islands Barty&gt; 样例输出 1234&gt; Yes&gt; No&gt; Yes&gt; 设置一个全局序号 用映射表将string 应设为 int 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;string&gt;using namespace std;bool G[105][105];int ids; //全局序号map&lt;string, int&gt; mp;int getId(string str) &#123; if (mp.count(str)) &#123; return mp[str]; &#125; else &#123; mp[str] = ++ids; return ids; &#125;&#125;int main() &#123; int n, m; ids = 0; cin &gt;&gt; n; while (n--) &#123; string a, b; cin &gt;&gt; a &gt;&gt; b; int x = getId(a); int y = getId(b); G[x][y] = true; G[y][x] = true; &#125; cin &gt;&gt; m; while (m--) &#123; string a, b; cin &gt;&gt; a &gt;&gt; b; int x = getId(a); int y = getId(b); if (G[x][y]) &#123; cout &lt;&lt; "Yes" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "No" &lt;&lt; endl; &#125; &#125;&#125; 葱头君的旅行 蒜头君所在的城市可以抽象成为一个有 n(1≤n≤20000) 个点和 m(1≤m≤50000) 条无向边的地图。 蒜头君住在 11 号点，他想进行一次环城市旅游。他从 1 点出发，每次沿着和 1 点相连的边中最短的边到下一个城市（如果有很多个最短的边，选择编号最小的走），到达下一个城市以后，还是沿着和这个城市相连的最短边走到下一个点（如果有很多个最短的边，选择编号最小的走），一直这样走下去，直到要走到一个已经走过的，就结束这次旅行。 输入格式 输入第一行两个整数 n，m。 接下来 m 行，每行输入三个整数 u,v(1≤u,v≤n,u!=v)，w(1≤w≤10^6)，表示有一条连接 u 和 v 长度为 w 的无向边。 输出格式 输出一行若干个整数，依次表示蒜头君旅行经过的点，每两个数中间用一个空格隔开。 样例输入 123456&gt; 4 4&gt; 3 4 4&gt; 4 2 5&gt; 2 1 7&gt; 4 1 5&gt; 样例输出 12&gt; 1 4 3&gt; 遍历点的邻接点，找到权值最小的那一个 设置一个bool数组vis 标记点是否被访问过 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;struct node &#123; int v, w; node(int _v, int _w):v(_v), w(_w) &#123;&#125;&#125;;vector&lt;node&gt; G[20000];bool vis[20000];void insert(int u, int v, int w) &#123; G[u].push_back(node(v, w)); G[v].push_back(node(u, w));&#125;void func(int v) &#123; vis[v] = true; int next = 0; node min_node = G[v][0]; for (int i = 0; i &lt; G[v].size(); i++) &#123; //找到一条最小的路径 if (G[v][i].w &lt; min_node.w) &#123; min_node = G[v][i]; next = i; &#125; &#125; if (vis[G[v][next].v]) &#123; cout &lt;&lt; v &lt;&lt; endl; return; &#125; else &#123; cout &lt;&lt; v &lt;&lt; " "; &#125; func(G[v][next].v);&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; while (m--) &#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; insert(u, v, w); &#125; func(1); return 0;&#125; 完全图判断 输入一个无向图，判断这个图是不是一个完全图。 输入格式 输入第一行两个整数 n(1≤n≤100) 和 m(1≤m≤20000)，表示输入点数和边数。 接下来 m 行，每行输入两个整数 u,v(1≤u,v≤n)，表示 u 和 v 之前有一条无向边。 输入中不存在自己到自己的边，但是可能会有重复的边。 输出格式 如果输入的图是一个完全图，输出&quot;Yes&quot;，否则输出&quot;No&quot;。 无向图是完全图时有 n*(n-1)/2条边 无向图的边(u, v) 和 (v, u) 是一样，所以插入集合前固定大小顺序 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;set&lt;pair&lt;int, int&gt; &gt; st;void swap(int &amp;a, int &amp;b) &#123; int tmp; tmp = a; a = b; b = tmp;&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; while (m--) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; if (u &gt; v) &#123; swap(u, v); &#125; st.insert(make_pair(u, v)); &#125; if (st.size() == n * (n - 1) / 2) &#123; cout &lt;&lt; "Yes" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "No" &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[19-04-21 听力词汇]]></title>
    <url>%2F2019%2F04%2F21%2F19-04-21%20%E5%90%AC%E5%8A%9B%E8%AF%8D%E6%B1%87%2F</url>
    <content type="text"><![CDATA[financial crises eloquent /‘ɛləkwənt/ adj. 雄辩的，有口才的 pension /‘pɛnʃən/ 养老金 drawback /‘drɔbæk/ n. 缺点，不利条件；退税 stereotype /‘stɛrɪətaɪp/ n. 陈腔滥调，老 slim /slɪm/ adj. 苗条的；修长的 hinder /‘hɪndɚ/ vt. 阻碍；打扰 adj. 后面的 sufficient /səˈfɪʃənt/ benefits 复数-&gt; 福利 n. 福利，效益 mortgage /‘mɔrɡɪdʒ/ 贷款 temperamental /‘tɛmprəmənt/ adj. 喜怒无常的；性情的；易兴奋的 insurance policy 保险单insure 上保险 insure your belongings 给你的财产上保险ensure 确保 downsize 规模上的缩小shrink lay offs 失业的人，解雇 经济类unemployment 失业job creation 创造就业 innovation 创新 banking industry 银行业 rescue package 政府救援计划reconstruction package 重建计划 wages and benefits 工资与福利 recession 经济下行 loans loans 贷款 small and medium-size enterprises 中小企业 bankruptcy 破产 校园场景类作业类(term) paper （学期）论文 essays 作文 thesis 毕业论文 dissertation 学术论文 journals 学术期刊 称谓类freshman n. 新手，生手 sophomore n. 大学二年级生；（美）有二年经验的人 junior 大三，年轻人 senior 大四，老年人，senior manager 高级经理 tutor 一对一的导师 tutoring server mentor 导师 supervisor 论文导师，上级，监督者 draft 草稿，初稿 I finish my draft graduate school 研究生院 department 系 undergraduate 本科生 post-graduate 研究生 课程：program, curriculum statistics 统计学 data processing interpreting advanced physics 高级物理 credit 学分 reading assignments rd作业 dormitory regulation 宿舍zc increasing tuitions 学费]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>词汇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[万能背景句]]></title>
    <url>%2F2019%2F04%2F19%2F19-04-19%20%E4%B8%87%E8%83%BD%E8%83%8C%E6%99%AF%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[现在分词做状语型 Time and again, science and technology has created wonders and even miracles, thus fortifying our belief in it. time and again adv. 屡次；常常 wonder /‘wʌndɚ/ n. 惊奇；奇观；惊愕 vi. 怀疑；想知道 miracle /‘mɪrəkl/ n. 奇迹 fortify /‘fɔrtɪfaɪ/ vt. 加强；增强 The Internet has penetrated every aspect of daily life, greatly affecting our ways of communication. penetrate /‘pɛnətret/ vt. 渗透；穿透；洞察 Technological innovation really brings us much convenience, exerting a huge impact on our traditional cultures. exert /ɪɡ’zɝt/ vt. 运用，发挥；施以影响 exert a impact on …. 对 … 施加影响 过去分词做状语 Invented less than a hundred years ago, computers are now used everywhere. ago 以前，以往 three days ago 三天前 定语从句 The reform and opening-up policy in China has led to rapid economic growth, which has given rise to a higher standard of living. 导致 ： lead to ; result in ; give rise to In recent years, China is marked by raped economic growth and continuous technological innovation]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>写作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[六级写作]]></title>
    <url>%2F2019%2F04%2F19%2F19-04-19%20%E5%85%AD%E7%BA%A7%E5%86%99%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[15 ~ 18 句左右 现在分词做状语状语，修饰动词或者修饰整个句子 ：时间，地点状语…… in the morning, in China (1) 主要动词与次要动词先比较，不超前，不落后，同时发生 他常常做在那里，思考这自己的未来He often sits there.He thinks about his future.当2句话主语动词同时发生，可以合并成一句， 主 + 谓 + 宾，doing/ doneHe often sits there, thinking about his future 我去北京的时候， 一心想快点赚钱When I went to Beijing, I hoped to earn quick money.I went to Beijing, hoping to earn(make) quick money. 我喜欢坐在茶馆里，听着音乐，喝着龙井茶I love to sit in the teahouses, listening to my music and drinking my Longjing tea. 环顾四周，我震惊地意识到我是车上剩下的唯一乘客I looked around.I realized with a shock that I was the only passenger left on the bus. (left -&gt; leave)因为后面一句太长，做次要部分有些变扭，所以把后面作为主句，前面作为次要部分Looking around, I realized with a shock that I was the only passenger left on bus. (2) 有时一个动作和另一个动作不是同时发生，但照顾到两个动作连贯，一气呵成。 他冲了出去，大声叫着He rushed out, shouting loudly. 过去分词做状语 从紫禁城顶上往下眺望，南京看起来很漂亮Nanjing is seen from top of the Purple Mountain.Nanjing looks beautiful.seen from top of the Purple mountain, Nanjing looks beautiful.seeing from top of the Purple mountain, we find Naning beautiful. 建于1885年，这是赛场上最老的赛车The car was built in 1885. (将主语和 be 动词省去)It was the oldest car at the race. （中文没有主语，添加主语it）Built in 1885, it was the oldest car at the race.英语中过去分词更喜欢放在主语之前，现在分词多放在主语之后 为这个奸邪的世道所伤，他丢下了一切，成为了一个和尚He was hurt by this evil world.He abandoned everything/left everything behind, becoming a monk.hurt by this wicked world, he abandoned everything/left everything behind, becoming a monk.leave behind 留下；遗留；超过 Terribly hurt by this wicked world, he left everything behind and become a monk.(2个动词用and并列) 对这个奸邪的世道已经失望，她纵深跳入河内Greatly disappointed at(in/ by) the wick world, she jumped into the river.disappoint v. 使失望 毁于1900年，圆明园去年得以重建Ruined in 1900，the Old Summer Place was rebuilt last year. 定语从句(从句也是一个完整的句子:有主 + 谓) (1)构成方式：先行词 + 关系代词 + 从句 现在站在街角的那个女人可能是我的邻居probably adv. 很可能corner n. 角落The woman who is standing at the street corner is probably my neighbor. 张艺谋因其创造性的想象力而蜚声于海内外，与团队努力奋斗，推出了恢宏的体育盛宴开幕式。ZYM, who has got a reputation for his creativity and imagination both at home and abroad, worked hard with his team to present the fantastic sport gala opening ceremony. get reputation 得到名誉creativity and imagination 创造力和想象力both at home and abroad 在国内外opening ceremony 开幕式gala n. 祝贺，庆祝非限制性定语从结局（加，），表明名词独一无二，物体用which,人用who 我父亲造的那个屋子有20年的历史 The house which my father built has a history of 20 years. (which 做宾语 可以省略) The house (which) was built by my father has a history of 20 years. the house built by my father 有多少年的历史： have a history of 这是我去年拜访的山村This is the mountain village (which) I visited last year.This is the mountain village where I visited last year. (X) (2) 关系代词在从句中做成分–主语或宾语，做宾语时可以省略。 这就是我出生和长大的地方grow up; be raised; be brought up; be bred; This is the place.I was born and raised in the place.This is the place which I was born and raised in. （介词in 要提前）This is the place in which I was born and raised .This is the place where I was born and raised. (不正式) (3) “介词 + 关系代词which” 表示地点 = where; 表时间 = when 我还记得我们相亲的那个冬日I still remember the winter day.we had our blind date on the winter day.I still remember the winter day on which we had our blind date. (on which = when) 非谓语动词n. 可以修饰 n. 的 分词可以做定语的哦！！！ doing(主动), done（被动）, to do 坐在教室里的一些学生正在准备考试Some students who are sitting in classroom are preparing for the coming exam.Some students sitting(分词) in classroom are preparing for the coming(分词做定语) exam 比赛中受伤的那条马腿马上就会康复The leg which was hurt in the race will recover soon.The leg hurt in the race will recover soon. recover 恢复 race /reɪs/ n.赛事，赛跑; 种；种族 倒装 （最后一段用） 对于一个年轻人，需要生吃俭用和辛苦工作，只有这样才能以较快的速度积累财富。a young man needs to save up and work hard. he can accumulate fortune in a quicker way.means n.方法mean v. 意思; adj.卑鄙 only in this way +(注意之间没有’,’) 倒装（情态动词, be动词, 助主动 提前）by this means = in this way A young man needs to save up and work hard. Only by this means can he gather a big fortune in a quicker way. 只有这样，我们才能取得成功；只有这样，我们的社会才能变的更加和谐Only by this way can we achieve sucess and Only by this means can our society become more harmonious to live in. 强调It is/was + 被强调部分 + that/who + 句子剩余部分 是团队合作最终最终使我们取得了成功 Teamwork makes it possible for us to achieve success. It is teamwork that makes it possible for us to achieve success. make it possible for sb. to … I met your mother in the street this morning.It was I who met your mother in the street this morning.It was your mother who I mer in the street this morning.It was in the street that I met …It was this morning that I met your … It is respect for other that allows one to gain respect. 虚拟语气It is important/ vital/ essential/ urgent/ imperative/ necessary that ... (should) 命令的口吻 imperative /ɪm’perətɪv/ adj. 必要的 我们马上找到他，这是很紧急的。It is essential that we should find him immediately. It is imperative that we should take actions to address the quandary.quandary n. 困惑；窘境；为难address the quandary It is important that he be operated on at once. It is high time that + 过去式 + should + do 是时候我们应该客观看待自己It is high time that we looked at ourselves objectively. It is high time that we took some measures.]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>写作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[绪论：初识机器学习]]></title>
    <url>%2F2019%2F04%2F19%2F19-04-19%20%E7%BB%AA%E8%AE%BA%EF%BC%9A%E5%88%9D%E8%AF%86%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[绪论：初识机器学习T 解决某一任务T E 从经验E中学习 P 进行某一性能度量 监督学习算法：我们给算法一个数据集，其中包含了正确答案，算法的目的就是给出更多的正确答案， 回归问题(Regression problem)：我们想要预测连续的数值输出 如：预测房价 分类问题(Classification problem)：设法预测一个离散值输出 0 或 1 (或者2个以上的输出值) 使用了特征或者说属性 可能会有处理很多特征的算法 如：医疗数据预测肿瘤 无监督学习（unsupervised）：对于给定的数据集，无监督学习算法可能判定，该数据集包含两个不同的簇，就是聚类算法 数据都有相同的标签或者都没有标签 聚类算法的例子：Google news, 基因组学，大型计算机集群（找出那些机器趋向于协同工作），社交网络分析（判断哪些人相互认识，在同一个社交圈），市场细分应用 （更具客户信息，将客户分到不同的细分市场）， 天文数据分析 我们只告诉算法这儿有一堆数据，不知道这些数据是是什么，是什么类型，自动找出这些数据的类型，按得到的类型把这些个体分成簇。 没有把数据集的正确答案给算法 鸡尾酒会问题]]></content>
      <categories>
        <category>机器学习笔记</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[六级词汇]]></title>
    <url>%2F2019%2F04%2F18%2F19-04-18%20%E5%85%AD%E7%BA%A7%E8%AF%8D%E6%B1%87%2F</url>
    <content type="text"><![CDATA[expose /ɪk&#39;spoz；ek-/ vt. 揭露，揭发；使曝光；显示 impose /ɪm&#39;poz/ vi. 利用；欺骗；施加影响; vt. 强加；征税；以…欺骗 dispose /dɪ&#39;spoz/ vt. 处理；处置；安排 -&gt;替换 solve mutual /&#39;mjutʃuəl/ adj. 共同的；相互的，彼此的 commodity /kə&#39;mɑdəti/ n. 商品，货物；日用品 reluctant /rɪ&#39;lʌktənt/ adj. 不情愿的；勉强的；]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>词汇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[翻译练习]]></title>
    <url>%2F2019%2F04%2F17%2F19-04-17%20%E7%BF%BB%E8%AF%91%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[2013 年 12月 第一套 中国园林（the Chinese garden） 是进过三千多年演变而成的独具一格的园林景观（landscape） After …, A 成为 B 园林成为景观 After 3000 years of evolution, the Chinese gardens have become a unique landscape. become -&gt; became -&gt; become 它既包括为皇室成员享乐而建造的大型花园，也包括学者，商人和卸任官员为摆脱吵杂的外部世界而建造的私家花园 It includes not only 大型花园 … but also … 私家花园 大型花园 for 皇室 to 享乐 私家花园 for 学者，商人和官员 to 摆脱… It include not only large gardens for royal(/‘rɒɪəl/ 皇家的) family to consume happiness but also private gardens for scholars( /‘skɒlə/ 学者), merchants and retired government officials to avoid the noisy outside world. 这些花园构成了一种意在表达人与自然之间应该有的和谐关系的微缩景观 花园 构成 景观 that 表达 和谐关系 between… The gardens have constituted(vt. 组成，构成) a miniature that expresses the harmonious(adj. 和谐的) relationship between man and nature. 典型的中国园林四周有围墙，园内有池塘，假山（rockwork）,树木，花草，以及各种各样由蜿蜒的小路和走廊连接的建筑 … has … There are … as well as … which are linked by …/ which link … The surrounding of a typical Chinese garden has walls, There are ponds, rockworks, trees, and flowers as well as various buildings which are linked by winding trails and corridors. various 各种各样的 漫步在花园中，人们可以看到一些列精心设计的景观犹如山水画卷(scroll) 一般展现在眼前 漫步ing in…, People may see 景观 which is like 山水画卷 Wandering in such a well-design garden, People may see the amazing landscape which is like a landscape picture scroll. 以后翻译时，“可以”不要翻译成can，替换成 may 不好嘛？ 2013 年 12月 第二套题 中国人自古以来就在中秋时节庆祝丰收，这与北美地区庆祝感恩节的习俗十分相似 Since 时间, … celebrate … in 时间， which is similar to 习俗 of 庆祝ing 感恩节 in 地点 时间地点 添加介词放句首或句尾 Since ancient times, the Chinese people usually celebrate harvest in the Mid-Autumn, which is similar to the custom of celebrating Thanksgiving in the North America. 自古以来：Since ancient times 过中秋节的习俗在唐代早期在中国各地开始流行，中秋节在农历八月十五，是人们拜月的节日 习俗 of 过ing 中秋 has become popular 地点 + 时间 中秋节，8月15 of 农历（作为插入语），is a day for people to 拜月 The tradition of celebrating Mid-Autumn has become popular all over China in the early Tang dynasty. The Mid-Autumn Festival,15th day of the 8th month of the lunar calendar, is a day for people worshiping(崇拜，拜神) the moon. 这天夜晚皓月当空，人们合家团聚，共赏明月 这天，family members 团聚 and 赏月（夜空的明月） At that day, family members get teoghter and enjoy the bright moon in the sky at night. On this day, under the dazzling(/‘dæzlɪŋ/ adj. 耀眼的) bright moon, families reunite( /riːjʊ’naɪt/ vt. 使重聚) and enjoy the moon’s beauty. 2006年，中秋节被列为中国的文化遗产，2008年又被定为公共假日 In 2006 , Mid-Autumn festival was listed as one of China’s cultural heritage, and in 2008, it was classified(classify v. 分类；分等) as a public holiday. China’s cultural heritage and 连接两个并列句，相同成分可以省略 In 2006, the Mid-Autumn was listed as a China cultural heritage, and in 2008 designated as a public holiday. (Mid-Autumn 和 be动词被省略了) 月饼被视为中秋节不可或缺的美食，人们将月饼作为礼物馈赠亲友或在家庭聚会上享用。 不可或缺的 美食 of 中秋节，被送给 朋友 as gift Moon cakes, as indispensable delicious food of the festival, were sent to families and friends during the festival as gifts and usually eaten on family gatherings, … is treated as …, which is used as 礼物 for 亲友 or which is enjoyed in 家庭聚会 The moon cake is treated as the indispensable food of the Festival, which is often used as gift for relatives (relatives) and friends or enjoyed in the family party.(并列句相同成分省略: which is ) 传统的月饼上带有“寿”(longevity)、“福”或“和”等字样。 There are character of “longevity”, “good fortune” and “harmony” on traditional moon cakes. … are imprinted with/ have Chinese characters, such as … or … such as … 等， 诸如， 等 Traditional moon cakes are imprinted with / have Chinese Characters, such as “” 2013 年 12月 第三套题 闻名于世的丝绸之路是一系列连接东西方的路线 The world-renowned Silk Road is a series of routes connecting the East and the West. world-renowned 世界知名的 renowned adj. 著名的，有声望 a series of.. … is … which 连接 … and … 丝绸之路延伸6000多公里，得名于古代中国的丝绸贸易 It extended … , which was named for its … The silk Road extends more than 6000 kilometers, which was named for its ancient chinese silk trade. 丝绸之路上的贸易在中国、南亚、欧洲和z中东文明发展中发挥着重要作用 …贸易 play an important role 在 … … 发挥重要作用 in 文明发展 of … Trades on the Silk Road played an important role in development of culture in China, South Asia, Europe and Africa. 正是通过丝绸之路，中国的造纸、火药、指南针、印刷术传遍各地 强调句(it + be + 被强调部分 + that …)，强调 通过丝绸之路 through the Silk Road It was 通过丝绸之路 that … were introduce around the world. It was through the Silk Road that Chinese papermaking, gunpowder, the compass and the printing press spread all over the world. all over the world 全世界 同样，中国的丝绸、茶叶和瓷器也传遍各地， Similarly, … spread all over the world. Similarly, Chinese silk, tea and porcelain spread all over the world via the Silk Road. 同样的： similarly 物质文化的交流是双向的，欧洲也是通过丝绸之路出口各种商品和植物，满足中国市场的需要。 … is … , Europe 出口 … and … through … to 满足 … The exchange of material and culture is mutual, Europe experted various commodities and plants through silk road to meet the needs of chinese market.]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[翻译]]></title>
    <url>%2F2019%2F04%2F16%2F19-04-16%20%E7%BF%BB%E8%AF%91%2F</url>
    <content type="text"><![CDATA[的， 是， 有 的：介词of 是： 有：there be, have, with 解决逗号 拆成若干个分句 介词短语+句子 with 句子+连词+句子 使用非谓语动词 词性转换解决中文多个动词有 你决定战胜复习考试的困难，这一点我很羡慕 从句：我羡慕that(宾语从句) 你决定 to 战胜 困难 of 复习ing 考试 从句：I admire that you decide to fight for the difficulties in preparing the examination. 词性转化：I admire your decision to fight for the difficulties in preparing the examination. 动词 -&gt; 名词 (英文爱用名词) 各地欢度春节的习俗和传统有很大差异 Customs and traditions about celebration of the Chinese New Year vary widely from place to place. 中文：动宾 =&gt; 名词 + 介词 + 名词 （英文爱用名词）庆祝春节：the celebration of the Chinese Year 这次事故是因为他玩忽职守而造成（因果关系）的 玩忽职守-&gt;失职 （动宾结构） This accident resulted from his neglect of duties. ! 当看见 “造成” 时，可能存在因果关系，-&gt; 考虑非常含蓄的应该关系 原因放前： 导致 result in结果放前： 归因于 result from 我的一些同学唱歌很好 Some of my classmates are good singers. 我们出口上述产品，已经经营了30年 We are exporters(出口商) of the above goods. running for 30 years. run a risk 冒险 他统治那个地区已经20年了He has been a ruler/dominator of that district for 20 years. 由动词派生的名词 + 后缀 火箭已经被用来探索宇宙Rockets have been used for the exploration (探究) of the universe. 动词 -&gt; 介词 通常每个家庭都会在除夕夜团聚，一起吃年夜饭 Chinese families gather for the annual(年度的) reunion dinner. 一个主语 + 2个动作：1 &amp; 2， 1 to 2 她转身蹦蹦跳跳地跑了，越过草地，踏上小径，跨上台阶，穿过凉台，进入门廊 Away she skipped over the grassland, up the path and the steps, across the veranda/ balony and into the porch/ lobby. 这里有许多山脉，生长着大片的森林，储藏着丰富的矿藏 There are mountains with extensive(大量的，广阔的) forests and rich mineral. 动词 -&gt; 形容词 be + adj 在清朝和明朝（the Ming and Qing Dynasties）时期，特别流行 It was widespread(adj. 普遍的，广泛的) particularly during the Ming and Qing dynasties. 他们不信任他，讨厌他They were suspicious and resentful(adj. 厌恶的) of him. 这个解决办法无法让人接受This solution is not acceptable. 一个好领导不满足于仅仅守住已有的成就A good leader is not content with merely taking care of / guarding what’s already there. 世界各地的观众都喜欢米老鼠的电影Movies about Mickey Mouse have been popular with audience everywhere.A about B : B 的 A 他们迫切地想获得消息 They were news-hungry. They are eager(adj. 渴望的) for getting news.eager adj. 渴望的；热切的；热心的 人们意识到… people are aware(adj. 意识的，知道的) that … 删除法 愚人会很快忘记说过的话，智者会很快放弃手里的钱A fool and his words are soon parted; a man of genius and his money.(A man of genius and his money = A man of genius and his money are soon parted) 他满怀希望地说谈判会取得成功He spoke hopefully of the success of the negotiation.取得成功 = 取得n. of 成功； 直接删去取得好了不影响意思 在观看篮球比赛之后，主席还有一个重要会议要参加After the basketball match, the chairman still has an important meeting.解决 ’ ,‘ 用 介词 after 这种新型飞机正越来越引起人们的注意—这种飞机体积不大，价格便宜A new kind of aircraft - small and cheap -(插入语) is attracting increasing attention.attract attention 吸引注意力 它的妻子认为，这件家具价格昂贵而且外表难看His wife thinks that this furniture is expensive and ugly.添了一个 is 成千上万的高校学生一起涌到火车站欢迎他们的足球队凯旋Thousands of student from the city’s colleges flooded into the railway station to welcome the arrival/triumphal of their football team.一个主语 2个动词，并且表示目的用 to 他没有致闭幕词就宣布会议结束He dismissed(解散； 解雇) the meeting without a closing speech. 我们不创造幸福就无权享受幸福，正如如果我们不创造财富就无权享受财富一样We have no more rights to consume happiness without producing it than to consume the wealth without creating it. 学而不思则罔，思而不学则殆Learn without thought is vain(徒劳的； 无用的); thought without learning is idle(闲置的). 时态转换 “在，正在，正” “着” 多用于表示动作正在进行过程中。 两方面因素推动着机器人技术发展：技术和经济Two factors are pushing the development of robots: technology and economics. “了”，“过” 表示行动已经发生 （现在完成时，一般过去时，过去完成时） 他去世时虽然仅32岁，他却已经创作了大量音乐。… ,but… 而but 之前有2个动词： [去世] [32岁(因为多大只能说 i am 32 years old)]Although he died when he was 32 years old, he wrote a prodigious(/prə’dɪdʒəs/; 巨大的) amount of music. 添加法1.添加代词 添加做主语的人称代词 我有很多美妙的想法，但是只把少数付诸实现了。中文没有主语的情况下：1.添加主语； 2.使用被动I had many wonderful ideas, but I only put a few into peactice.a few (有a 肯，没a 否，小样的(little)，不可数) 汉语中若无主语，补加代词做主语 活到老，学到老We live and learn 人生的意义不在于已经获取的，而在于渴望得到什么样的东西The significance of a life is not in what the person attained but rather in what he longs to attain.long to 渴望 添加作宾语的代词 他越想掩盖他的错误，就越容易暴露The more he tried to hide his mistakes, the more he revealed them 添加物主代词 她睁大双眼，听我说话1 and 2 She listened to me with her rounded eyes. 2.代词 it 的添加 时间，天气等， 固定句型 我花了很长时间才到了医院It takes sb. sometime to do sth. (非谓语动词做主语，为了避免头重脚轻，用it来做形式主语，正在主语在后面)It is adj. for sb. to do sth. (所以翻译时，从后向前翻译，做什么事情对某人来说是……)It took me a long time to reach the hospital. 人民才是最强大的 （这是一个强调句: It be +被强调部分(主语、宾语 或 状语)+who (that)...）It is the people who are really powerful. 3.添加连接词 他看上去有些忧愁不安He looked gloomy and troubled 时间不早了，你最好回家As it is late, you had better go home. 早知如此，我就不参加了if I had known it, I would not have joined in to. 4.添加冠词 在过去，飞往月球是绝对办不到的事情It is out of the question to fly to the moon in the past.out of the question 不可能的 月亮慢慢从海上升起The moon was slowly rising above the sea. 当中文有“一个，每个， 这个，那个”等含义时需要冠词 他说，他一英里就赚一块钱He said he gets a dollar a mile. 5.添加介词 添加表示时间的介词 一九九七年七月，香港回归中国On July 1, 1997, Hong Kong returned to the People’s Republic of China 添加表示地点的介词 冬天，北方的天气比南方冷的多In winter, it is much colder in the North than it is in the South.比较结构：前后可比性 6.添加动词 必须在购货单规定的时间交货Delivery must be reached within the time stated on the purchase order. 只有定语从句选择与中文意思无关 名词性从句转换主语从句 我们何时才能开始这次研究仍然是悬而未决。When we can begin the research is still a question.(从句连词比谓语动词少一个) 他准备怎么做这个事情是一个迷How he is going to do it is a mystery. 宾语从句 他已经通知我他们将在什么时候谈论我的建议He has informed me when they are to discuss my proposal( 提议). 一般将来时： will + v(原形) be going to do sth. be to do sth. be about to do sth. 表语从句 问题是我们能否赢得大多数人民群众的支持The question is whether we can win the majority of the people. 他对新闻界的看法是，记者们不是支持他，就是反对他His view of the press is that the reporters were either for him or against him.for against 都是介词，不然句子中介词太多了 同位语从句 我们已经得出这样的结论：实践是检验真理的标准We have reach the conclusion that practice is the criterion(标准；准则) for testing truth.draw the conclusion 得出结论；推断 科学家们获得了一个令人振奋的发现—可以把这种废物变成碎料The scientist made an exciting discovery that this waste material could be turned into plastics. 定语从句转换1.后置法：当中文有“的”字时， 把定语从句翻译到所修饰的先行词后面 （名词之后）奔跑的肥猪 -&gt; 肥猪 that is 奔跑 太空和海洋是科学家们努力探索的新领域Space and oceans are the new world which scientist are trying to explore. 他那富有感染力的笑声打破了沉寂His laughter, which was infectious(传染的；传染性的), broke the silence(沉寂). which was infectious &lt;=&gt; 动词 -&gt; be + adj 2.当中文有表示时间的含义时 司机在开车时，不许和人谈话，也不能走神 when… 司机 who 开车…A driver who is driving the bus mustn’t talk with others or be absent-minded. 3.当文中有表示“原因”的含义 他似乎不愿意再和史密斯太太讲话，因为她现在令人厌烦unwilling adj. 不愿意 show no wish He showed no wish for conversion with Mrs. Smith who was now more than usually disagreeable. more than = very 4.当文中表示“条件”的含义 人们极其迫切地要求工作，不管什么工作，只要它能维持一家人的生活就行Men become desperate(不顾一切的；令人绝望的) for work, any work, which will help them to keep alive their families. desperate for 渴望; 急需 5.当中文中有表示”让步“的含义 尽管他并没有这样的需求，他坚持要再买一栋房子He insisted on buying another house,which he had no use for. insist on 6.当中文表示目的的含义 为了引起公众对这件事情的注意，他想写一篇文章He wishes to write an article that will attract the public attention to the matter. 状语从句转换当..., 一... 就..., 直到... 才 , 自从.... , 在... 之前 , 在.... 之后 时间状语从句 他结束讲话的时候，听众掌声雷动 As he finish the speech, the audience burst into applause(n. 欢呼，喝采). burst into applause 爆发出热烈的掌声 我一安排好就通知你 … as soon as … 一 …… 就 …… I’ll let you know as soon as I arranged it. 原因状语从句因为：seeing that(由于；因为), considering that(考虑到…，就…而论), in that(因为；由于) 气体不同于固体是因为（就在于）他没有固体的形状 be + adj. 因为 … 没有： don’t have; have no differ from = be different from fixed 永恒的， 固定的 A gas differs from solid in that it has no fixed shape. 他将得到提升，因为他工作干得好 promotion n.提升 He will get promotion for he has done good work. 理论之所以有价值，是因为它能给实践指出方向 theory /‘θɪərɪ/ n. 理论；原理 给 -&gt; provide valuable /‘væljʊəb(ə)l/ n. adj. 有价值的；贵重的; n. 贵重物品 practice /‘præktɪs/ n. 实践；练习；惯例; v be + adj. 表示动词 Theory is valuable because it can provide a direction for practice. 条件状语从句虚拟语气 ： 假的话就用虚拟，客观事实不用虚拟 表示条件功能： if , in the event that ...(如果，万一；在……情况下) , provided that...(如果；条件是；倘若) 假如你把一切都告诉我，那么我就能够做出绝定 if you tell me about it, then I shall be able to decide. 毫无疑问， 我本来是可以赚到一点的，如果我真有那样打算的话 out of question 毫无疑问 mean: 意思； 打算； 小气 It is no doubt that I could have earned something if I had really meant to. 让步状语从句no matter (who/how/when/where/…)… though /ðəʊ/ granted that : granted: conj. 诚然; adv. 的确 即使你不喜欢这个建议，你也不应该没有同别人商量就把他否决了 不应该后面有2个动词,而真正要做的是否决，没有商量用 without proposal /prə’pozl/ n. 提议，建议；求婚 consult /kən&#39;sʌlt/v. 商量；向…请教 Granted that you don’t like the proposal, you shouldn’t have rejected it without consulting others. 目的状语从句 为了：so that , in order that , in order to, so as to, to/for, with the purpose of 以防，万一：lest, for fear that, in case (必须用虚拟语气 should + do (should 可以省略)) 他反复强调这一点，免得她忘了。 He emphasized it again and again lest she should forget. 他们躲在树丛后面，以防被敌人发现 They hide behind some bushes for fear that the enemy should find them. 结果状语从句所以 他做了错误的决定，结果浪费了自己半生的时间中文没有主语：1. 添加主语 2. 使用被动语态He made a wrong decision, so that half of his lifetime was wasted.当 so that 做所以的时候，前面必须用逗号隔开当 so that 前没有逗号时，是： 为了so … that … 如此 … 以至于… 被动语态的转换 主动语态表示主语是动作的执行者，被动语态表示主语是动作的承受者 Many people speak English.English is spoken by many people. 主动改成被动的方法 将主动语态的宾语改为被动语态的主语 将主动语态的谓语动词改为 “be + 过去分词” 结构 主动语态的主语改为介词by之后的宾语，放在谓语动词之后（有时可省略） 含直接宾语和间接宾语的主动语态改为被动语态时有两种情况~（直接宾语是谓语动词的承受者，间接宾语表示谓语动作的方向（对谁做）或动作的目标（为谁做），间接宾语紧接在谓语动词后，但它不能单独存在）~ He gave me a book. 他给我一本书(me作间接宾语，a book作直接宾语) 把间接宾语改为被动语态的主语，直接宾语保留原位； 把直接宾语改为被动语态的主语，此时，间接宾语前要加介词 to 或 for;I was given a book.A book was given to me. 不带 to 的动词不定式做宾语补足语的主动语态，改为被动语态时不定式前面要加to 2种动词在主动句中没有to, 而在被动句中要加to : 1.感官动词 2. 使役动词 They watched the children sing that morning. The children were watched to sing that morning. 带复合宾语（宾补）的动词在改为被动时，一般把主动语态宾语改为主语，宾语补足语在被动语态中做主语补足语 We call him Xiao Wang.He is called Xiao Wang. 被动语态的使用情况 有 “被， 受， 遭， 让， 给， 由， 把， 得到， 收到， 加以， 得以， 为…所， 由…来” 时 中文没有主语的句子 选择动作的承受者做英文主语时 她爸爸送给她一支新钢笔 She was given a new pen by her father. A new pen was given to her by her father. 我们在这里所说的话，人们不会长久记住，然而我们在这里所做的事，却能改变世界 What we say here will not be long remembered, but what we do here can change the world. 已经采取了措施来防止这种流行病迅速蔓延 prevent from 阻止prevent disease from spreading 防止这种疾病蔓延epidemic n. 传染病; adj. 流行的；传染性的 Measures have been taken to prevent the epidemic from spreading quickly. 印刷术是从中国传入欧洲的 Printing was introduced into Eurrope from China. 美国学分制是1872年在哈佛大学首先事实的 credit 学分； 信用 The credit system in America was first adopted by Harvard University in 1872. 中国的老人仍旧要由家庭来赡养 elderly adj. 上了年纪的 China’s elderly will be provided for by their families. 常用被动句型 “It + 被动语态 + that” 的翻译 有人认为，心理学是一门复杂的学科 It is considered that psychology is a complex subject. 有人说,科学的范畴可以分为2个主要的领域：自然科学和社会科学 field 领域 area n. 区域，地区；面积；范围 It stressed that the field of science may be divided into two major areas: natural science and social science.]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chap1 MATLAB 入门基础]]></title>
    <url>%2F2019%2F04%2F13%2F19-04-13%20matlab-Chap1%2F</url>
    <content type="text"><![CDATA[数据的输入123456% 换行分号，行末分号A = [1 2 3; 4 5 6; 7 8 10]% 加减乘除，幂a=29*(2+23/3)-5^2% 返回值=函数名（参数1，参数2，……）a=magic(3) Tab键补全功能，语法提示，错误纠正12345678910111213141516171819&gt;&gt; Sin(pi) Did you mean:&gt;&gt; sin(pi)&gt;&gt; a=[1 2 4 9;16 25 36 49];&gt;&gt; a([3 6])=nan; %将数组第6个元素和第7个元素赋为NaN, 注意数组元素下标是竖着数的&gt;&gt; mean(a) %求平均数，默认是对对第一维度，即列 =&gt; mean(a, 1)ans = 8.5000 NaN NaN 29.0000 &gt;&gt; mean(a,'omitnan') %忽略NaNans = 8.5000 25.0000 4.0000 29.0000 &gt;&gt; mean(a,2,'omitnan') %对第二维度求平均值，忽略NaNans = 4.6667 30.0000 科学计数法123&gt;&gt; a=10000000000000000000000000000000000000a = 1.0000e+37 相对精度eps = 2.2204e-16 123456789101112&gt;&gt; a=10000000000000000; %1E16&gt;&gt; b=10000000000000001;&gt;&gt; c=a-bc = 0 &gt;&gt; a1=1000000000000000; %1E15&gt;&gt; b1=1000000000000001;&gt;&gt; c1=a1-b1c1 = -1 ans，NaN，inf，eps，i，j，pi1234567891011121314151617181920&gt;&gt; 2+3ans = 5 &gt;&gt; 0/0ans = NaN &gt;&gt; 2/0ans = Inf &gt;&gt; ians = 0.0000 + 1.0000i &gt;&gt; jans = 0.0000 + 1.0000i&gt;&gt; 2+3ians = 2.0000 + 3.0000i&gt;&gt; pians = 3.1416 开立方根123456789&gt;&gt; a=-8;&gt;&gt; r=a^(1/3)r = 1.0000 + 1.7321i %默认放回第一象限解m=[0,1,2]; % 为3个方根而设R=abs(a)^(1/3) % 模的开3次方theta=(angle(a)+2*pi*m)/3 % -pi&lt;theta&lt;=pi的3个相位角r=R*exp(i*theta) % 将得到的结果赋给r 命令行换行输入&gt;&gt; a=1 % 按Shift+Enter快捷键暂不执行此行命令，并进入下一行输入b=2 % 按 Shift+Enter快捷键进入下一行输入，此时还可以编辑本行或上面一行命令c=a+b % 按回车键运行全部3行命令 当用户输入有关键词的多行循环命令时，例如for和end，并不需要使用Shift+Enter快捷键，直接按回车键即可进入下一行输入，直到完成了循环体之后，MATLAB才会将各行程序一起执行。 123for r=1:5 % 按回车键a=pi*r^2 % 按回车键end % 按回车键并执行循环体内的命令 在同一行内输入多个函数x = (1:10)&#39;; logs = [x log10(x)] 长命令行的分行输入12headers = ['Author First Name, Author Middle Initial ' ...'Author Last Name '] 标识符(…)如果出现在两个单引号的中间，MATLAB则会报错 Format long /short /compact/loose 调整数据显示格式format long %长整型显示格式format short %短整型显示格式format compact %压缩空格format loose %松散 clc，clear，close all 清屏, 清除内存, 关闭所有的Figure窗口空格的作用123456&gt;&gt; a3=[7 - 2 + 5]a3 = 10&gt;&gt; a4=[7 -2 +5]a4 = 7 -2 5 冒号的作用a=2:2:20 %从2 ~ 20 步长为2 特殊矩阵的生成函数123456ones(4) % 创建所有元素为1的矩阵rand(2,3) % 创建2*3的均匀分布随机数矩阵&gt;&gt; randperm(7) % 创建由1∶7构成的随机数列ans = 6 3 7 5 1 2 4 随机种子的设置 不同版本设置方式有所不同，根据提示来 12% rand('state', 0); % 14b% rng(0) % 17a 数组矩阵寻访 全下标标识 1234&gt;&gt; a=[1 2 3; 4 5 6] % 创建测试矩阵&gt;&gt; A=a(2,2) % 全下标寻访A = 5 单下标标识 123&gt;&gt; b=a(4) % 单下标寻访b = 5 逻辑1标识 12345678910111213&gt;&gt; B=a&gt;5 % 返回逻辑下标B = 2×3 logical array 0 0 0 0 0 1 &gt;&gt; c=a(B) % 逻辑下标寻访c = 6 &gt;&gt; C=a(a&gt;5) C = 6 冒号 1234567891011121314151617&gt;&gt; d=a(1,:) % 通过使用冒号可以寻访全行元素d = 1 2 3&gt;&gt; e=a(:,2) % 通过使用冒号可以寻访全列元素d = 2 5 &gt;&gt; f=a(:) % 单下标寻访f = 1 4 2 5 3 6 向量/数组 1234&gt;&gt; g=a(:,[1 3]) % 寻访地址可以是向量，以同时寻访多个元素g = 1 3 4 6 数组矩阵操作 矩阵的合并 123456789&gt;&gt; A = ones(2, 5) * 6; % 元素全部为6的2´5矩阵&gt;&gt; B = rand(3, 5); % 3´5 的随机数矩阵&gt;&gt; C = [A; B]C = 6.0000 6.0000 6.0000 6.0000 6.0000 6.0000 6.0000 6.0000 6.0000 6.0000 0.5469 0.1576 0.4854 0.4218 0.9595 0.9575 0.9706 0.8003 0.9157 0.6557 0.9649 0.9572 0.1419 0.7922 0.0357 矩阵的赋值 1234a=magic(4)a(3,4)=0 % 对单个元素进行赋值a(:,1)=1 % 对第一列进行赋值a(14)=16 % 采用全下标对第14个元素进行赋值 矩阵的转置 12345678&gt;&gt; A = [1 2; 3 4]A = 1 2 3 4&gt;&gt; A'ans = 1 3 2 4 数组运算和矩阵运算的区别 12a=[1 2 4 9;16 25 36 49]b=sqrt(a) % 应用函数对矩阵中的每一个元素分别开方 矩阵的形状信息 123456789101112&gt;&gt; A = rand(5,3) * 10 % 生成5´5的随机矩阵&gt;&gt; size(A)ans = 5 3&gt;&gt; a=length(A) %对于维度较多的数组，长度为max(size(A))b=sum(A(:))/numel(A) % 使用Sum和numel函数计算矩阵A的平均值 numel:Number of array elementsmean(A) %第一维度（列）求平均数mean(A,2) %第二维度（行）求平均数mean(A(:)) %整个数组平均数mean(mean(A)) 数组运算和矩阵运算的比较 12345678910111213141516A=[1 2;3 4] % 测试矩阵AB=[4 3;2 1] % 测试矩阵Br1=100+A % 矩阵A加上一个常数r2_1=A*B % 两个矩阵相乘，矩阵乘法r2_2=A.*B % 两个矩阵相乘，数组乘法r3_1=A\B % 矩阵左除r3_2=A.\B % 数组除法r4_1=B/A % 矩阵右除r4_2=B./A % 数组除法r5_1=A.^2 % 数组幂r5_2=A^2 % 矩阵幂r6_1=2.^A % 数组幂r6_1 = 2 4 8 16 矩阵元素的扩展与删除 12345A=magic(4)A(6,7)=17 %直接赋值就可以扩充A(:,8)=ones(6,1)A(:,1)=[] % 删除矩阵A的第1列A(2,:)=[] % 删除矩阵A的第2行 矩阵的重构 1234567891011121314151617181920212223&gt;&gt; a=reshape(1:9,3,3) % 创建测试矩阵a = 1 4 7 2 5 8 3 6 9&gt;&gt; a= [1,7;2,8;3,9;4,10;5,11;6,12]; % 创建测试矩阵&gt;&gt; a = reshape(a,4,3) % 使用reshape改变a的形状a = 1 5 9 2 6 10 3 7 11 4 8 12% 注意前后两个a每一个单下标对应的元素是一致的&gt;&gt; b=rot90(a,3) % 将矩阵a逆时针旋转3×90°b = 4 3 2 1 8 7 6 5 12 11 10 9c=fliplr(a) % 将矩阵a左右翻转d=flipud(a) % 将矩阵a上下翻转 稀疏矩阵，创建，与普通矩阵转换，视图 12345678910&gt;&gt; A=[0 0 0 1;0 1 0 0;1 2 0 0;0 0 3 0];&gt;&gt; s=sparse(A)s = (3,1) 1 (2,2) 1 (3,2) 2 (4,3) 3 (1,4) 1B=full(s) %还原成普通矩阵 使用函数sparse，可以用一组非零元素直接创建一个稀疏矩阵。该函数调用格式为：S=sparse(i,j,s,m,n)其中i和j都为矢量，分别是指矩阵中非零元素的行号与列号，s是一个全部为非零元素矢量，元素在矩阵中排列的位置为(i,j)。m为输出的稀疏矩阵的行数，n为输出的稀疏矩阵的列数。 1234S=sparse([1 3 2 1 4],[3 1 4 1 4],[1 2 3 4 5],4,4) %行号矢量，列号矢量， 值矢量full(S)B = bucky;spy(B) %画图 多维数组创建多维数组最常用的方法有以下4种。 直接通过“全下标”元素赋值的方式创建多维数组。 由若干同样尺寸的二维数组组合成多维数组。 由函数ones、zeros、rand、randn等直接创建特殊多维数组。 借助cat、repmat、reshape等函数构建多维数组。 123456789101112131415161718&gt;&gt; clear %%%%记得要清内存啊啊&gt;&gt; A(3,3,3)=1 % 创建3*3*3数组，未赋值元素默认设置为0A = (:,:,1) = 0 0 0 0 0 0 0 0 0 (:,:,2) = 0 0 0 0 0 0 0 0 0 (:,:,3) = 0 0 0 0 0 0 0 0 1 12345678910111213141516171819202122B(3,4,:)=1:4 % 创建3*4*4数组B = (:,:,1) = 0 0 0 0 0 0 0 0 0 0 0 1 (:,:,2) = 0 0 0 0 0 0 0 0 0 0 0 2 (:,:,3) = 0 0 0 0 0 0 0 0 0 0 0 3 (:,:,4) = 0 0 0 0 0 0 0 0 0 0 0 4 123456789101112131415161718192021C(:,:,1)=magic(4); % 创建数组A第1页的数据C(:,:,2)=ones(4); % 创建数组A第2页的数据C(:,:,3)=zeros(4) % 创建数组A第3页的数据C = (:,:,1) = 16 2 3 13 5 11 10 8 9 7 6 12 4 14 15 1(:,:,2) = 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1(:,:,3) = 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 12345678910111213141516171819202122232425262728293031323334D=rand(3,4,3) % 由函数rand直接创建特殊多维数组&gt;&gt; E3=cat(3,ones(2,3),ones(2,3)*2,ones(2,3)*3) %借助cat函数构建多维数组E3 = (:,:,1) = 1 1 1 1 1 1(:,:,2) = 2 2 2 2 2 2(:,:,3) = 3 3 3 3 3 3&gt;&gt; E2=cat(2,ones(2,3),ones(2,3)*2,ones(2,3)*3) %借助cat函数构建多维数组E2 = 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3&gt;&gt; E1=cat(1,ones(2,3),ones(2,3)*2,ones(2,3)*3) %借助cat函数构建多维数组E1 = 1 1 1 1 1 1 2 2 2 2 2 2 3 3 3 3 3 3 12345678e=[1,2;3,4;5,6]F=repmat(e,[1,2,3])G=reshape(1:60,5,4,3)H=reshape(G,4,5,3)I=flip(H,1)J=shiftdim(H,1) % 将各维向左移动1位，使2*3*3数组变成3*3*2数组K=shiftdim(H,2) % 将各维向左移动2位，使2*3*3数组变成3*2*3数组 运算D=shiftdim(A,1)实现以下操作：D(j,k,i)=A(i,j,k)，i, j, k分别是指各维的下标。对于三维数组，D=shiftdim(A,3)的操作就等同于简单的D=A。 数据类型 数值型 …… 逻辑型 123456789101112131415161718192021&gt;&gt; a=[1 2 3; 4 5 6] % 创建测试矩阵&gt;&gt; B=a&gt;5 % 返回逻辑下标B = 0 0 0 0 0 1&gt;&gt; c=true(size(a))c = 1 1 1 1 1 1&gt;&gt; false([size(a),2]) %=&gt; false(2, 3, 2])ans = (:,:,1) = 0 0 0 0 0 0(:,:,2) = 0 0 0 0 0 0 练习 123456789101112131415161718192021a=[1 2 3;4 5 6];b=[1 0 0;0 -2 1];A=a&amp;b % 逻辑“与”B=a|b % 逻辑“或”C=~b % 逻辑“非”a=[1 1 0; 1 0 0;1 0 1]A=all(a) % 每列元素均为非零时返回真B=any(a) % 每列元素存在非零时返回真&gt;&gt; a=[0 -1 2];&gt;&gt; b=[-3 1 2];&gt;&gt; a&lt;b % 对应元素比较大小ans = 0 1 0a&gt;b % 对应元素比较大小a&lt;=b % 对应元素比较大小a&gt;=b % 对应元素比较大小a==b % 对应元素比较相等&gt;&gt; a~=b % 对应元素比较不相等ans = 1 1 0 运算符优先级 字符和字符串12345678910111213141516171819202122232425&gt;&gt; a = 'matlab'a =matlab&gt;&gt; size(a)ans = 1 6&gt;&gt; A='中文字符串输入演示';&gt;&gt; A(3:5)ans = 字符串 &gt;&gt; S=['This string array ''has multiple rows.']S = This string array has multiple rows.&gt;&gt; a=char('这','字符','串数组','','由5 行组成')a = 这 字符 串数组 由5 行组成% 以字符最多的一行为准，而将其他行中的字符以空格补齐 结构数组 12345678910&gt;&gt; employee.name='henry';&gt;&gt; employee.sex='male';&gt;&gt; employee.age=25;&gt;&gt; employee.number=12345;&gt;&gt; employeeemployee = name: 'henry' sex: 'male' age: 25 number: 12345 结构还可以通过赋值的方式扩展为结构数组 1234567891011121314151617&gt;&gt; employee(2).name='lee';&gt;&gt; employee(2).sex='female';&gt;&gt; employee(2).age=23;&gt;&gt; employee(2).number=98765;&gt;&gt; employee(2)employee = name: 'henry' sex: 'male' age: 25 number: 12345 &gt;&gt; employee % 查看employee结构数组employee = name sex age number 子域 1234567891011121314&gt;&gt; green_house.name='一号房'; &gt;&gt; green_house.volume='2000 立方米'; &gt;&gt; green_house.parameter.temperature=...[31.2 30.4 31.6 28.7;29.7 31.1 30.9 29.6]; %子域温度&gt;&gt; green_house.parameter.humidity=...[62.1 59.5 57.7 61.5;62.0 61.9 59.2 57.5]; %子域湿度&gt;&gt; green_house.parameter % 显示域的内容ans = temperature: [2×4 double] humidity: [2×4 double]&gt;&gt; green_house.parameter.temperature % 显示子域中的内容ans = 31.2000 30.4000 31.6000 28.7000 29.7000 31.1000 30.9000 29.6000 元胞数组 创建元胞数组 1234567&gt;&gt; A = &#123;[1 4 3; 0 5 8; 7 2 9], 'Anne Smith'; 3+7i, -pi:pi/4:pi&#125;A = [3×3 double] 'Anne Smith' [3.0000 + 7.0000i] [1×9 double]&gt;&gt; header = &#123;'Name', 'Age', 'Pulse/Temp/BP'&#125;; % 元胞数组的创建&gt;&gt; records(1,:) = &#123;'Kelly', 49, &#123;58, 98.3, [103, 72]&#125;&#125;; % 嵌套元胞数组的创建 依次创建元胞数组 12345678910111213141516171819202122232425262728293031323334353637clearA(1,1) = &#123;[1 4 3; 0 5 8; 7 2 9]&#125;;A(1,2) = &#123;'Anne Smith'&#125;;A(2,1) = &#123;3+7i&#125;;A(2,2) = &#123;-pi:pi/4:pi&#125;;A(3,3) = &#123;5&#125;A = [3×3 double] 'Anne Smith' [] [3.0000 + 7.0000i] [1×9 double] [] [] [] [5]&gt;&gt; str=A&#123;1,2&#125; % 返回字符型数组str，a&#123;1,2&#125;表示对应元胞的内容str = 'Anne Smith'&gt;&gt; class(str) % 查看变量str的数据类型，结果确为字符型ans = 'char'&gt;&gt; str2=A(1,2) % a(1,2)表示元胞数组中的一个元胞str2 = cell 'Anne Smith'&gt;&gt; class(str2) % 查看变量str2的数据类型，结果为元胞数组ans = 'cell'&gt;&gt; [nrows, ncols] = cellfun(@size, A) % 将size函数应用于每一个元胞元素ncols = 3 10 0 1 9 0 0 0 1ncols = 3 10 0 1 9 0 0 0 1cellplot(A) % 以图片表示元胞数组的基本结构 日期和时间12345678910111213t = datetime(2017,8,28,6:7,0,0)t.Dayt.Day = 27:28t.Formatt.Format = 'MMMdd日, yyyy年't2 = datetime(2017,7,29,6,30,45)d = t - t2d.Format = 'h'd.Format = 'd'load('datahis.mat') % 载入时间、风速、功率等测试数据plot(datahis0.t_his,datahis0.v)plot(datetime(datevec(datahis0.t_his)),datahis0.v) Tables 表格数组12T = readtable(&apos;patients.dat&apos;) % 读取表格数据T(1:5,1:5) 可通过以下方式直接创建 123456LastName = &#123;'Smith';'Johnson';'Williams';'Jones';'Brown'&#125;;Age = [38;43;38;40;49];Height = [71;69;64;67;64];Weight = [176;163;131;133;119];BloodPressure = [124 93; 109 77; 125 83; 117 75; 122 80];T = table(LastName,Age,Height,Weight,BloodPressure) 表可以像普通数值矩阵那样通过小括号加下标来进行寻访。除了数值和逻辑型下标之外，用户还可以使用变量名和行名来作为下标。例如本例中可以使用LastName作为行名，然后将这一列数据删除。 123456clearT = readtable('patients.dat') % 读取表格数据T.Properties.RowNames = T.LastName;T.LastName = [];size(T) % 查看当前表T的尺寸T(1:5,6:9) 基于已有变量（身高和体重）用户可以创建新的变量BMI，也就是体重指数。然后还可以添加变量的单位和描述等属性。T.BMI = (T.Weight0.453592)./(T.Height0.0254).^2;T.Properties.VariableUnits{‘BMI’} = ‘kg/m^2’;T.Properties.VariableDescriptions{‘BMI’} = ‘Body Mass Index’;size(T) % 查看当前表的尺寸 导数1234A=randperm(9) % 生成随机数列B = diff(A) % 求数列的差分C = pascal(6)D = diff(C) % 对矩阵C列方向各元素进行差分计算 梯度 FX = gradient(F)：返回F的一维数值梯度，F是一个向量。 [FX,FY] = gradient(F)：返回二维数值梯度的x和y部分，F是一个矩阵。 [FX,FY,FZ,…] = gradient(F)：求高维矩阵F的数值梯度。 […] = gradient(F,h)：h是一个标量，用于指定各个方向上点之间的间距。 […] = gradient(F,h1,h2,…)：指定各个方向上的间距。 12345v = -2:0.2:2;[x,y] = meshgrid(v);z = x .* exp(-x.^2 - y.^2); % 创建测试数据[px,py] = gradient(z,.2,.2); % 求梯度contour(v,v,z), hold on, quiver(v,v,px,py), hold off % 绘制等高线和梯度方向]]></content>
      <categories>
        <category>数学建模</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深搜的剪枝策略]]></title>
    <url>%2F2019%2F04%2F11%2F19-04-11%20%E6%B7%B1%E6%90%9C%E7%9A%84%E5%89%AA%E6%9E%9D%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[可行性剪枝搜索过程中，一旦发现某些状态无论如何都不能找到最终解，就可以将其“剪枝”了 从1 ~ 30 选出8个数，使得和值为200 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;int n, k, sum, ans;int a[40];void dfs(int i, int cnt, int s) &#123;//i: 数组索引位置； cnt: 以选数据个数; s: 和 if (cnt &gt; k) &#123; //可行性剪枝，选择数的个数不可能超过k return; &#125; if (s &gt; sum) &#123; //可行性剪枝,s大于sum的不用考虑 return; &#125; if (i == n) &#123; if (cnt == k &amp;&amp; s == sum) &#123; ans++; &#125; return; &#125; dfs(i + 1, cnt, s); //不选第i个数 dfs(i + 1, cnt + 1, s + a[i]); //选第i个数&#125;int main() &#123; n = 30; k = 8; sum = 200; for (int i = 0; i &lt; 30; i++) &#123; a[i] = i + 1; &#125; ans = 0; dfs(0, 0, 0); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 最优性剪枝最优解问题，通常可以用最优性剪枝，如在求解迷宫最短路的时候，若发现当前的步数已经超过了当前最优解，那从当前状态开始的搜索都是多余的 在搜索是否有可行解的过程中，一旦找到了一组可行解，后面的搜索都不必再进行了，（最优性剪枝的特例） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int n, m;string mp[110];bool vis[110][110];int dir[4][2] = &#123;&#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;&#125;;const int INF = 0x3f3f3f3f;int ans = INF;bool in(int x, int y)&#123; return 0 &lt;= x &amp;&amp; x &lt; n &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; m;&#125;void dfs(int x, int y, int step)&#123; if (step &gt; ans) &#123; //不可能再是最优解，不用再算了 return; &#125; if (mp[x][y] == 'T') &#123; ans = step; return; &#125; vis[x][y] = true; for (int i = 0; i &lt; 4; i++) &#123; int tx = x + dir[i][0]; int ty = y + dir[i][1]; if (in(tx, ty) &amp;&amp; mp[tx][ty] != '*' &amp;&amp; !vis[tx][ty]) &#123; dfs(tx, ty, step + 1); &#125; &#125; vis[x][y] = false;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; mp[i]; &#125; int x, y; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (mp[i][j] == 'S') &#123; x = i, y = j; &#125; &#125; &#125; dfs(x, y, 0); cout &lt;&lt; ans &lt;&lt; endl;&#125; 重复性剪枝对于某一些特定的搜索方式，一个方案可能会被搜索很多次，这样是没必要的。 给定 n 个整数，要求选出 K 个数，使得选出来的 K 个数的和为 sum。 那么 1, 2, 3这个选取方法能被搜索到 6 次，这是没必要的，因为我们只关注选出来的数的和，而根本不会关注选出来的数的顺序，所以这里可以用重复性剪枝。 我们规定选出来的数的位置是递增的，在搜索的时候，用一个参数来记录上一次选取的数的位置，那么此次选择我们从这个数之后开始选取，这样最后选出来的方案就不会重复了。 当然，搜索的效率也要比直接二进制枚举更高。 1234567891011void dfs(int s, int cnt, int pos) &#123; ... ... for (int i = pos; i &lt;= n; i++) &#123; if (!xuan[i]) &#123; xuan[i] = true; dfs(s + a[i], cnt + 1, i + 1); // i + 1 表示从上一次选取的位置后面开始选 xuan[i] = false; &#125; &#125;&#125; 奇偶性剪枝 有一个 n×m 大小的迷宫。其中字符&#39;S&#39;表示起点，字符&#39;D&#39;表示出口，字符&#39;X&#39;表示墙壁，字符&#39;.&#39;表示平地。你需要从&#39;S&#39;出发走到&#39;D&#39;，每次只能向上下左右相邻的位置移动，并且不能走出地图，也不能走进墙壁。每次移动消耗 1 时间，走过路都会塌陷，因此不能走回头路或者原地不动。现在已知出口的大门会在 T 时间打开，判断在 0 时间从起点出发能否逃离迷宫。 数据范围 n,m≤10,T≤50。 我们只需要用DFS来搜索每条路线，并且只需搜到 T 时间就可以了（这是一个可行性剪枝）。但是仅仅这样也无法通过本题，还需考虑更多的剪枝。如上图所示，将 n×m 的网格染成黑白两色。我们记每个格子的行数和列数之和为 x，如果 x 为偶数，那么格子就是白色，反之奇数时为黑色。容易发现相邻的两个格子的颜色肯定不一样，也就是说每走一步颜色都会不一样。更普遍的结论是：走奇数步会改变颜色，走偶数步颜色不变。 那么如果起点和终点的颜色一样，而 T 是奇数的话，就不可能逃离迷宫。同理，如果起点和终点的颜色不一样，而 T 是偶数的话，也不能逃离迷宫。遇到这两种情况时，就不用进行DFS了，直接输出&quot;NO&quot;。 这样的剪枝就是奇偶性剪枝，本质上也属于可行性剪枝。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;const int N = 10;int n, m, T;string mp[N];bool vis[N][N];int dx[4] = &#123;0, 0, -1, 1&#125;;int dy[4] = &#123;1, -1, 0, 0&#125;;bool ok;//x, y 坐标； t 时间void dfs(int x, int y, int t) &#123; if (ok) return; //最优性剪枝 if (t == T) &#123; if (mp[x][y] == 'D') ok = true; return; //可行性剪枝 &#125; vis[x][y] = true; for (int i = 0; i &lt; 4; i++) &#123; int tx = x + dx[i]; int ty = y + dy[i]; if (0 &lt;= tx &amp;&amp; tx &lt; n &amp;&amp; 0 &lt;= ty &amp;&amp; ty &lt; m &amp;&amp; mp[tx][ty] != 'X' &amp;&amp; !vis[tx][ty]) &#123; dfs(tx, ty, t + 1); &#125; &#125; vis[x][y] = false;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; T; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; mp[i]; &#125; int sx, sy, ex, ey; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (mp[i][j] == 'S') sx = i, sy = j; if (mp[i][j] == 'D') ex = i, ey = j; &#125; &#125; if ((sx + sy + ex + ey + T) % 2 != 0) &#123; //奇偶性剪枝 cout &lt;&lt; "NO" &lt;&lt; endl; &#125; else &#123; ok = false; dfs(sx, sy, 0); if (ok) &#123; cout &lt;&lt; "YES" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "NO" &lt;&lt; endl; &#125; &#125; return 0;&#125; 剪枝例题 引爆炸弹 在一个 n×m 的方格地图上，某些方格上放置着炸弹。手动引爆一个炸弹以后，炸弹会把炸弹所在的行和列上的所有炸弹引爆，被引爆的炸弹又能引爆其他炸弹，这样连锁下去。现在为了引爆地图上的所有炸弹，需要手动引爆其中一些炸弹，为了把危险程度降到最低，请算出最少手动引爆多少个炸弹可以把地图上的所有炸弹引爆。数据范围：1≤n,m≤1000； 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;int n, m;char mp[1000][1000];bool row[1010], col[1010]; //标记行和列是否被访问过void dfs(int x, int y) &#123; mp[x][y] = '0'; if (!row[x]) &#123; row[x] = true; // 若该行没有被访问过，则这次引爆该行 for (int i = 0; i &lt; m; i++) &#123; if (mp[x][i] == '1') &#123; dfs(x, i); &#125; &#125; &#125; if (!col[y]) &#123; col[y] = true; // 若该列没有被访问过，则这次引爆该列 for (int i = 0; i &lt; n; i++) &#123; if (mp[i][y] == '1') &#123; dfs(i, y); &#125; &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; mp[i]; &#125; int cnt = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (mp[i][j] == '1') &#123; cnt++; dfs(i, j); &#125; &#125; &#125; cout &lt;&lt; cnt &lt;&lt; endl;&#125; 找数字 - (抽象dfs + 剪枝) 给一个数 n，让你找出一个只由 0,1 组成的十进制数 m，要求这个正整数 m 可以被 n 整除。输入格式：输入一个整数 n (1≤n&lt;200)。输出格式：对于输入整数 n 的每一个值，输出 m 的相应值，保证有一个数字长度小于 19 位的数字。如果有一个给定值 n 有多个解，其中任何一个都是可以接受的。本题答案不唯一，符合要求的答案均正确样例输入复制： 12&gt; 2&gt; 样例输出复制： 12&gt; 10&gt; 2分支dfs,要么后面加0，要么后面加1 特别注意不是所有分支都有结果，所以要剪枝 注意条件保证有结果长度小于19，所以当长度大于等于19,return 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int n;bool ok;void dfs(long long s, int cnt) &#123; if (ok) return; //最优性剪枝，已经找到了可行解，没有必要继续搜索 if (cnt &gt;= 19) &#123; //递归出口1，字符串长度超过19 return; &#125; if (s % n == 0) &#123; //递归出口2,找到了可行性答案 ok = true; cout &lt;&lt; s &lt;&lt; endl; return; &#125; dfs(s * 10, cnt + 1); dfs(s * 10 + 1, cnt + 1);&#125;int main() &#123; cin &gt;&gt; n; dfs(1, 0); //因为是正整数，故不能为0 return 0;&#125; 全排列 从 n 个不同元素中任取 m (m≤n) 个元素，按照一定的顺序排列起来，叫做从 n 个不同元素中取出 m 个元素的一个排列。当m=n 时所有的排列情况叫全排列。今天这道题目很简单就是给你一个整数n ，计算 [1,n] 所有数字的排列组合。输入格式：第一行输入一个整数 n(1≤n≤9).输出格式：第一行输出一个全排列的方案总数 m。接下来按照字典序依次输出这 m 个排列。排列的字典的比较方法和字符串一样，比如两个排列 a,b，从第一个数开始，找到第一个不同的数的位置为 ii，然后比较 a[i] 和 b[i] 的大小，如果 a[i] 小的，那么 a 的字典序就小，否则 b 的字典序更小。样例输入1: 12&gt; 2&gt; 样例输出1 1234&gt; 2&gt; 12&gt; 21&gt; 也可以用 next_permutation() 来做 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;string&gt;using namespace std;//--------int n;bool vis[10];//n个位置，从1~n中选一个数塞进去，void dfs(int num, int cnt) &#123; if (cnt == n) &#123; cout &lt;&lt; num &lt;&lt; endl; return; //小心别少啦！ &#125; for (int i = 1; i &lt;= n; i++) &#123; //对于每一个位置，去枚举每一个可以用的数 if (!vis[i]) &#123; //如果之前没有被用过 vis[i] = true; //标记使用该数 dfs(num * 10 + i, cnt + 1); //对于这种全是数字的用，当成数字拼接好了 vis[i] = false; //去试探别的数前，要取消对该数的标记 &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n; int ans = 1; for (int i = 1; i &lt;= n; i++) &#123; ans *= i; &#125; cout &lt;&lt; ans &lt;&lt; endl; dfs(0, 0); return 0;&#125; 蒜头君的旅游计划 马上就要放寒假了，蒜头君已经辛勤的工作一年了，打算和家人一起出去旅游放松放松。有经验的人一定知道，出去旅游前一定要有详细的旅行规划。蒜头君打算旅游 n 个城市，但并不是每条路线的花费都是一样的。蒜头君是一个勤俭节俭的人，他就在想怎么把所有的城市旅游一遍花费最小呢？（蒜头君不喜欢重复旅游同一个城市，也就是说已到达过的城市蒜头君是不会再次光临的） 输入格式 第一行输入一个整数 n(1≤n≤15)，表示有 n 个城市。 接下来有一个 n×n 的矩形，表示每两个城市之间的火车花费，每两个城市之间的花费不会超过 10000。 输出格式 输出一个整数，表示从 11 号城市把所有景点旅游一遍并且回到 11 号城市的最小花费。 样例输入 123456&gt; 4&gt; 0 1 1 1&gt; 1 0 2 1&gt; 5 5 0 6&gt; 1 1 3 0&gt; 样例输出 12&gt; 8&gt; 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int G[20][20];bool vis[20];int n, ans = 0x3f3f3f;// u:当前所在点 cnt:所走步数 sum：总花费void dfs(int u, int cnt, int sum) &#123; if (sum &gt; ans) &#123; //最优性剪枝 return; &#125; if (cnt == n - 1) &#123; ans = min(ans, sum + G[u][0]); &#125; vis[u] = true; //标记在循环外，包含源点，循环n-1次，到达目的 for (int i = 0; i &lt; n; i++) &#123; if(!vis[i]) &#123; dfs(i, cnt + 1, sum + G[u][i]); &#125; &#125; vis[u] = false;&#125;int main() &#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; G[i][j]; &#125; &#125; dfs(0, 0, 0); cout &lt;&lt; ans; return 0;&#125; 蒜头君手上有一些小木棍，它们长短不一，蒜头君想用这些木棍拼出一个正方形，并且每根木棍都要用到。 例如，蒜头君手上有长度为 1，2，3，3, 3 的 5 根木棍，他可以让长度为1，2 的木棍组成一条边，另外三根分别组成 3 条边，拼成一个边长为 3 的正方形。蒜头君希望你提前告诉他能不能拼出来，免得白费功夫。 输入格式 首先输入一个整数 n(4≤n≤20)，表示木棍数量，接下来输入 n 根木棍的长度 pi(1≤pi≤10000)。 输出格式 如果蒜头君能拼出正方形，输出&quot;Yes&quot;，否则输出&quot;No&quot;。 样例输入1复 123&gt; 4&gt; 1 1 1 1&gt; 样例输出1复 12&gt; Yes&gt; 样例输入2 123&gt; 5&gt; 10 20 30 40 50&gt; 样例输出2 12&gt; No&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int p[25];bool vis[25];int n;int sum = 0;bool ok;void dfs(int s, int cnt, int pos) &#123; if (ok) &#123; //最优性剪枝 return; &#125; if (s &gt; sum / 4) &#123; //注意这里是sum / 4, 别写成 sum % 4 return; &#125; if (s == sum / 4) &#123; dfs(0, cnt + 1, 0); //pos 重新从0开始搜素 return; &#125; if (cnt == 4) &#123; ok = true; return; &#125; for (int i = pos; i &lt; n; i++) &#123; //重复性剪枝 if (!vis[i]) &#123; vis[i] = true; //虽然使用重复性剪枝，但是重新搜索时 pos 从0开始 dfs(s + p[i], cnt, i + 1); vis[i] = false; &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; p[i]; sum += p[i]; &#125; if (sum % 4 != 0) &#123; cout &lt;&lt; "No" &lt;&lt; endl; &#125; else &#123; dfs(0, 0, 0); if (ok) &#123; cout &lt;&lt; "Yes" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "No" &lt;&lt; endl; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab学习]]></title>
    <url>%2F2019%2F04%2F08%2F19-04-08%20matlab%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[矩阵操作对应位置相乘 A .* B 对应位置相除 A ./ B 对应位置平方 A .^ B 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&gt;&gt; A = [1 2 3; 4 5 6; 7 8 9];&gt;&gt; x = A(1, 3)x = 3A = 1 2 3 4 5 6 7 8 9&gt;&gt; A(6) %matlab 单索引是竖着数的ans = 8&gt;&gt; A(1, :) %取出第一行ans = 1 2 3 &gt;&gt; A(1:2, 1:3) %取出第 1, 2 行ans = 1 2 3 4 5 6 &gt;&gt; A(2, :) = [1 1 1] %给某一行赋值A = 1 2 3 1 1 1 7 8 9 &gt;&gt; A(1:2, 1:2) = [-1 -2; -3 -4]A = -1 -2 3 -3 -4 1 7 8 9 数组比较和逻辑运算123456789101112131415161718192021222324252627%比较和逻辑运算 &gt;&gt; x = [1 2 3 4 5 6 7 8 9];&gt;&gt; y = [1 4 3 8 5 6 7 8 9];&gt;&gt; eq = (x == y) % 找出数组x和y中相等的元素eq = 1×9 logical array 1 0 1 0 1 1 1 1 1&gt;&gt; ep = (x&gt;5)&amp;(y&lt;7) % 找出数组x, y 中 x &gt;5 &amp;&amp; y &lt; 7ep = 1×9 logical array 0 0 0 0 0 1 0 0 0&gt;&gt; xoy = xor(x&gt;5, y&lt;7) % 异或，一个真一个假才为真xoy = 1×9 logical array 1 1 1 0 1 0 1 1 1 1234&gt;&gt; x = [1 -2 3 -4 5 -6 7 -8 9];&gt;&gt; x(x&lt;0) = 0 %把数组x 中小于0 的都变成0x = 1 0 3 0 5 0 7 0 9 123456&gt;&gt; y = [1 2 3; -4 5 6; 7 8 9];&gt;&gt; y(y(:,1)&lt;0,:) = 0 %将第一列小于0 的那一行赋值为0y = 1 2 3 0 0 0 7 8 9 数组操作函数：flipud, fliplr, rot90 , sum , max, minflipud矩阵上下旋转 123456&gt;&gt; A = [1 2 3; 4 5 6; 7 8 9];&gt;&gt; B = flipud(A)B = 7 8 9 4 5 6 1 2 3 fliplr 矩阵左右旋转 123456&gt;&gt; A = [1 2 3; 4 5 6; 7 8 9];&gt;&gt; C = fliplr(A)C = 3 2 1 6 5 4 9 8 7 rot90 逆时针旋转90° 123456&gt;&gt; A = [1 2 3; 4 5 6; 7 8 9];&gt;&gt; D = rot90(A)D = 3 6 9 2 5 8 1 4 7 sum 求和 123456789101112131415161718192021222324252627282930313233343536&gt;&gt; A = [1 2 3];&gt;&gt; sum(A)ans = 6 &gt;&gt; B = [1 2 3; 4 5 6; 7 8 9];&gt;&gt; sum(B) %sum对矩阵求和，是把每一列相加 =&gt; sum(B,1)ans = 12 15 18 &gt;&gt; sum(B, 2) %sum对第2维度相加，即每一行求和ans = 6 15 24 &gt;&gt; sum(sum(B))ans = 45 &gt;&gt; sum(B(:))ans = 45 &gt;&gt; C = B(:) %将B拉成一个列向量C = 1 4 7 2 5 8 3 6 9 max, min 123456789101112131415161718&gt;&gt; A = [1 2 3];&gt;&gt; max(A)ans = 3 &gt;&gt; max(A,2) %将2和数组中每一个元素比较，返回大的，也是一个数组ans = 2 2 3 &gt;&gt; B = [1 3 9; 4 8 6];&gt;&gt; max(B) %当是一个二维数组时取，每一列的最大值 = max(B, [], 1)ans = 4 8 9 &gt;&gt; max(B, [], 2) %对每一行去最大值ans = 9 8 常用的数学函数：sin, cos, tan, cot, asin, acos, atan, acot abs, sqrt ceil, floor , fix (向0靠), round (四舍五入取整) 基本语句1234for .. endif .. else .. endwhile .. endswitch .. case .. end]]></content>
      <categories>
        <category>数学建模</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2019%2F04%2F06%2F19-04-06%20test%2F</url>
    <content type="text"><![CDATA[[TOC] 大纲plethora n.过多，过剩 /&#39;pleθ(ə)rə/ ple:full (plenty of 许多) replete a.充满的 be ~ with (re:again) deplete v.耗尽 (de:not) provident a.有远见的, 未雨绸缪的 /&#39;prɒvɪd(ə)nt/ vis/vid : to see (visit/visible) envisage v.展望,设想 (en:to) invidious a.招人讨厌的 (in:not 不愿意看见你–烦银) /ɪn&#39;vɪdɪəs/ improvise v.即兴创作 (in:not pro:前 , 不用之前看) /&#39;ɪmprəvaɪz/ 字母变化规律 元音之间可以互换 a,e,i,o,u,y clarity n.清楚,明晰 —–clear nominate v.提名 ——name + in + ate gild v.镀金 ——gold grisly a.可怕的, 毛骨悚然的 —–gray +sly fetter n.脚镣 v.束缚 —–feet 辅音之间的互换 p - b t - d k - g - c - qu f - v s - z - x - th 12345reimburse v.报销; 偿还 re:back + in + pursesunder v.分开, 分裂 thunder 雷ascetic a.苦行的, 禁欲的 athletic : 古希腊人竞技前禁欲masquerade n.假面舞会 mask : 面具miscellaneous a.各种各样的，混杂的 mix : 混合 字母 g , h 的脱落 sheeny a.光亮的, 有关泽的 –shine : 闪耀–sun feign v.假装 —–feint v./n 假装,佯攻 arduous a.辛苦的, 费力的 —– hard + uous 形近字母的变化 m - n u - v - w 123lurk v.潜伏 ---lower + krenovate v.翻新 ---re + new + ateprudent a.谨慎的 ---provident 固定转换 s - t - d p - b - f - v - ph 1234conclude ~ conclusionamorphous a.无形状的 a:not + morph:form +ousdissent v.不同意 ---dis + sense (感觉不同)pyromania n.纵火狂 pyro---firemania 同源词之间的联系：读音、拼写、意思lesson 1 consecrate v.供奉，奉为圣神 1234567sacr--sacred/holy(sacrifice)sacrilegedesecrateexecrate**devoteprofane(谐：泼粪) evoke v.唤起，引起 12345678910vok/voc -- to call(voice)convoke [喊到一起来]revoke re:backequivocal equal(相等的) + voc 说话声音相似/相等invoke in:to 加强provoke 在面前喊 vociferous voice fer: to carry**fueltrigger bereave v.使丧失；剥夺 be:to 加强 a bereave mother 失去孩子的母亲 be bereft of 失去…… 12345678910rav/rap 抢夺(rob)rapacious acious adj.后缀 ...多rapt enraptureravage age n.后缀ravish ish v.后缀**deprivelootdespoil abdomen n.腹部，肚子 ab+do+men 做一个正真的男人，人到中年肚子凸显 12belly (记：ball)paunch (pocket) obsolete a.做废的，过时的 12345ob: against sol: solere(be used to)联想：ob+sole 唯一 只剩下一个过时的**outmoded a.过时的antiquated antique 古董的]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>词汇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F06%2F19-04-06%20hello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
